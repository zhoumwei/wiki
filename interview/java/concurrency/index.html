<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Java 多线程详解 | 知识库</title><meta name="description" content="涵盖Java、Spring、Vue、Node.js等技术知识">
    <link rel="stylesheet" href="/wiki/assets/css/styles.2a121ef9.css">
    <link rel="preload" href="/wiki/assets/js/runtime~app.46b38a58.js" as="script"><link rel="preload" href="/wiki/assets/css/styles.2a121ef9.css" as="style"><link rel="preload" href="/wiki/assets/js/768.e6d4205d.js" as="script"><link rel="preload" href="/wiki/assets/js/app.6ec2591a.js" as="script">
    <link rel="prefetch" href="/wiki/assets/js/solution_smart-marketing_index.html.c6a04243.js" as="script"><link rel="prefetch" href="/wiki/assets/js/solution_high-availability_index.html.1ef390b5.js" as="script"><link rel="prefetch" href="/wiki/assets/js/tutorial_react_index.html.4aacb360.js" as="script"><link rel="prefetch" href="/wiki/assets/js/solution_aiops_index.html.9565eae6.js" as="script"><link rel="prefetch" href="/wiki/assets/js/tutorial_swift_index.html.26390310.js" as="script"><link rel="prefetch" href="/wiki/assets/js/tutorial_embedded_index.html.1d42b838.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_nodejs_index.html.42d74f45.js" as="script"><link rel="prefetch" href="/wiki/assets/js/tutorial_python_index.html.e9a522b3.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_spring-boot_index.html.38761574.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_java_jdk-changes_index.html.25824bdf.js" as="script"><link rel="prefetch" href="/wiki/assets/js/tutorial_r_index.html.16153cc5.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_vue_index.html.63167ab5.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_java_concurrency_index.html.e362b849.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_java_advanced_index.html.71c33c5c.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_spring-cloud_index.html.fd0f185e.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_message-queue_index.html.b4b3c3e6.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_big-data_index.html.bbd64ec0.js" as="script"><link rel="prefetch" href="/wiki/assets/js/tutorial_llm_index.html.09e48380.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_database_index.html.14a46108.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_java_basic_index.html.bddf19ef.js" as="script"><link rel="prefetch" href="/wiki/assets/js/tutorial_ml_index.html.7188e38d.js" as="script"><link rel="prefetch" href="/wiki/assets/js/interview_java_collections_index.html.0c5ba651.js" as="script"><link rel="prefetch" href="/wiki/assets/js/tutorial_rl_index.html.6c114c3c.js" as="script"><link rel="prefetch" href="/wiki/assets/js/get-started.html.c4557635.js" as="script"><link rel="prefetch" href="/wiki/assets/js/index.html.c33a2346.js" as="script"><link rel="prefetch" href="/wiki/assets/js/404.html.a5b4614e.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/wiki/"><img class="vp-site-logo" src="/wiki/logo/new-logo.svg" alt="知识库"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">知识库</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/wiki/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/wiki/get-started.html" aria-label="开始阅读"><!--[--><!--[--><!--]--><!--]-->开始阅读<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/java/basic/" aria-label="Java基础"><!--[--><!--[--><!--]--><!--]-->Java基础<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/java/advanced/" aria-label="Java高级"><!--[--><!--[--><!--]--><!--]-->Java高级<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/java/collections/" aria-label="Java集合详解"><!--[--><!--[--><!--]--><!--]-->Java集合详解<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/wiki/interview/java/concurrency/" aria-label="Java多线程详解"><!--[--><!--[--><!--]--><!--]-->Java多线程详解<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/java/jdk-changes/" aria-label="JDK版本变化详解"><!--[--><!--[--><!--]--><!--]-->JDK版本变化详解<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Spring"><span class="title">Spring</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Spring"><span class="title">Spring</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/spring-boot/" aria-label="Spring Boot"><!--[--><!--[--><!--]--><!--]-->Spring Boot<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/spring-cloud/" aria-label="Spring Cloud"><!--[--><!--[--><!--]--><!--]-->Spring Cloud<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="解决方案"><span class="title">解决方案</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="解决方案"><span class="title">解决方案</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/solution/aiops/" aria-label="AIOps"><!--[--><!--[--><!--]--><!--]-->AIOps<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/solution/high-availability/" aria-label="高可用架构"><!--[--><!--[--><!--]--><!--]-->高可用架构<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/solution/smart-marketing/" aria-label="智能营销"><!--[--><!--[--><!--]--><!--]-->智能营销<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/wiki/" aria-label="首页"><!--[--><!--[--><!--]--><!--]-->首页<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/wiki/get-started.html" aria-label="开始阅读"><!--[--><!--[--><!--]--><!--]-->开始阅读<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Java"><span class="title">Java</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Java"><span class="title">Java</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/java/basic/" aria-label="Java基础"><!--[--><!--[--><!--]--><!--]-->Java基础<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/java/advanced/" aria-label="Java高级"><!--[--><!--[--><!--]--><!--]-->Java高级<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/java/collections/" aria-label="Java集合详解"><!--[--><!--[--><!--]--><!--]-->Java集合详解<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link route-link-active auto-link" href="/wiki/interview/java/concurrency/" aria-label="Java多线程详解"><!--[--><!--[--><!--]--><!--]-->Java多线程详解<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/java/jdk-changes/" aria-label="JDK版本变化详解"><!--[--><!--[--><!--]--><!--]-->JDK版本变化详解<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="Spring"><span class="title">Spring</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="Spring"><span class="title">Spring</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/spring-boot/" aria-label="Spring Boot"><!--[--><!--[--><!--]--><!--]-->Spring Boot<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/interview/spring-cloud/" aria-label="Spring Cloud"><!--[--><!--[--><!--]--><!--]-->Spring Cloud<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="解决方案"><span class="title">解决方案</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="解决方案"><span class="title">解决方案</span><span class="right arrow"></span></button><ul class="vp-navbar-dropdown" style="display:none;"><!--[--><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/solution/aiops/" aria-label="AIOps"><!--[--><!--[--><!--]--><!--]-->AIOps<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/solution/high-availability/" aria-label="高可用架构"><!--[--><!--[--><!--]--><!--]-->高可用架构<!--[--><!--[--><!--]--><!--]--></a></li><li class="vp-navbar-dropdown-item"><a class="route-link auto-link" href="/wiki/solution/smart-marketing/" aria-label="智能营销"><!--[--><!--[--><!--]--><!--]-->智能营销<!--[--><!--[--><!--]--><!--]--></a></li><!--]--></ul></div></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><a class="route-link route-link-active auto-link vp-sidebar-item vp-sidebar-heading active" href="/wiki/interview/java/concurrency/" aria-label="Java多线程详解"><!--[--><!--[--><!--]--><!--]-->Java多线程详解<!--[--><!--[--><!--]--><!--]--></a><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="java-多线程详解" tabindex="-1"><a class="header-anchor" href="#java-多线程详解"><span>Java 多线程详解</span></a></h1><h2 id="_1-线程基础概念" tabindex="-1"><a class="header-anchor" href="#_1-线程基础概念"><span>1. 线程基础概念</span></a></h2><h3 id="q1-什么是进程和线程" tabindex="-1"><a class="header-anchor" href="#q1-什么是进程和线程"><span>Q1: 什么是进程和线程？</span></a></h3><p><strong>答：</strong></p><ul><li><strong>进程</strong>：是操作系统分配资源的基本单位，每个进程都有独立的内存空间</li><li><strong>线程</strong>：是CPU调度的基本单位，同一进程内的线程共享进程的内存空间</li></ul><p>主要区别：</p><ol><li>地址空间：进程间相互独立，线程间共享所属进程的资源</li><li>开销：进程创建和销毁开销大，线程相对较小</li><li>切换：进程切换开销大，线程切换开销小</li><li>通信：进程间通信需要IPC机制，线程间可直接读写进程数据</li></ol><h3 id="q2-为什么要使用多线程" tabindex="-1"><a class="header-anchor" href="#q2-为什么要使用多线程"><span>Q2: 为什么要使用多线程？</span></a></h3><p><strong>答：</strong> 使用多线程的主要原因包括：</p><ol><li><strong>提高性能</strong>：充分利用多核CPU的计算能力</li><li><strong>改善用户体验</strong>：避免界面卡顿，提升响应速度</li><li><strong>提高资源利用率</strong>：当一个线程等待I/O时，其他线程可以继续执行</li><li><strong>简化程序设计</strong>：某些业务逻辑天然适合并发处理</li></ol><h3 id="q3-线程有哪些状态" tabindex="-1"><a class="header-anchor" href="#q3-线程有哪些状态"><span>Q3: 线程有哪些状态？</span></a></h3><p><strong>答：</strong> Java线程有6种状态：</p><ol><li><strong>NEW</strong>：新建状态，线程刚创建还未调用start()方法</li><li><strong>RUNNABLE</strong>：就绪状态，线程正在JVM中执行，可能正在等待OS资源（如处理器）</li><li><strong>BLOCKED</strong>：阻塞状态，线程等待监视器锁进入同步块/方法</li><li><strong>WAITING</strong>：等待状态，线程无限期等待其他线程执行特定动作</li><li><strong>TIMED_WAITING</strong>：超时等待状态，线程等待其他线程执行特定动作，但设置了超时时间</li><li><strong>TERMINATED</strong>：终止状态，线程执行完毕</li></ol><h2 id="_2-创建线程的方式" tabindex="-1"><a class="header-anchor" href="#_2-创建线程的方式"><span>2. 创建线程的方式</span></a></h2><h3 id="q4-创建线程有哪几种方式" tabindex="-1"><a class="header-anchor" href="#q4-创建线程有哪几种方式"><span>Q4: 创建线程有哪几种方式？</span></a></h3><p><strong>答：</strong> 创建线程主要有以下几种方式：</p><ol><li><p><strong>继承Thread类</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 线程执行代码</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// 使用</span></span>
<span class="line"><span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>实现Runnable接口</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 线程执行代码</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// 使用</span></span>
<span class="line"><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>实现Callable接口</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 线程执行代码，有返回值</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token string">&quot;执行结果&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// 使用</span></span>
<span class="line"><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>使用线程池</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 线程执行代码</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="q5-runnable和callable的区别" tabindex="-1"><a class="header-anchor" href="#q5-runnable和callable的区别"><span>Q5: Runnable和Callable的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>Runnable</th><th>Callable</th></tr></thead><tbody><tr><td>返回值</td><td>无返回值</td><td>有返回值</td></tr><tr><td>异常处理</td><td>不能抛出受检异常</td><td>可以抛出受检异常</td></tr><tr><td>实现方法</td><td>run()</td><td>call()</td></tr><tr><td>使用场景</td><td>一般任务执行</td><td>有返回结果的任务</td></tr></tbody></table><h2 id="_3-线程同步与锁机制" tabindex="-1"><a class="header-anchor" href="#_3-线程同步与锁机制"><span>3. 线程同步与锁机制</span></a></h2><h3 id="q6-synchronized关键字的作用和用法" tabindex="-1"><a class="header-anchor" href="#q6-synchronized关键字的作用和用法"><span>Q6: synchronized关键字的作用和用法？</span></a></h3><p><strong>答：</strong> synchronized关键字用于实现线程同步，确保同一时刻只有一个线程执行特定代码块。</p><p>用法：</p><ol><li><p><strong>修饰实例方法</strong>：锁住当前实例对象</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 代码 */</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>修饰静态方法</strong>：锁住当前类的Class对象</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 代码 */</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>修饰代码块</strong>：指定加锁对象</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 代码 */</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><h3 id="q7-volatile关键字的作用" tabindex="-1"><a class="header-anchor" href="#q7-volatile关键字的作用"><span>Q7: volatile关键字的作用？</span></a></h3><p><strong>答：</strong> volatile关键字有两个主要作用：</p><ol><li><strong>可见性</strong>：确保变量修改对所有线程立即可见</li><li><strong>禁止指令重排序</strong>：防止JVM对代码进行优化重排序</li></ol><p>注意：volatile不能保证原子性，只保证可见性和有序性。</p><h3 id="q8-reentrantlock和synchronized的区别" tabindex="-1"><a class="header-anchor" href="#q8-reentrantlock和synchronized的区别"><span>Q8: ReentrantLock和synchronized的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>ReentrantLock</th><th>synchronized</th></tr></thead><tbody><tr><td>锁获取方式</td><td>显式获取和释放</td><td>隐式获取和释放</td></tr><tr><td>可中断</td><td>支持</td><td>不支持</td></tr><tr><td>超时获取</td><td>支持</td><td>不支持</td></tr><tr><td>公平锁</td><td>支持</td><td>不支持</td></tr><tr><td>锁绑定条件</td><td>支持多个Condition</td><td>不支持</td></tr><tr><td>性能</td><td>竞争激烈时表现更好</td><td>竞争不激烈时性能较好</td></tr></tbody></table><h2 id="_4-线程间通信" tabindex="-1"><a class="header-anchor" href="#_4-线程间通信"><span>4. 线程间通信</span></a></h2><h3 id="q9-wait-、notify-和notifyall-的作用" tabindex="-1"><a class="header-anchor" href="#q9-wait-、notify-和notifyall-的作用"><span>Q9: wait()、notify()和notifyAll()的作用？</span></a></h3><p><strong>答：</strong></p><ul><li><strong>wait()</strong>：使当前线程等待并释放锁，直到其他线程调用notify()或notifyAll()</li><li><strong>notify()</strong>：唤醒在此对象监视器上等待的单个线程</li><li><strong>notifyAll()</strong>：唤醒在此对象监视器上等待的所有线程</li></ul><p>注意事项：</p><ol><li>这些方法只能在同步方法或同步块中调用</li><li>调用wait()后线程会释放锁，而sleep()不会释放锁</li><li>通常使用while循环而不是if语句来检查条件</li></ol><h3 id="q10-threadlocal的原理和使用场景" tabindex="-1"><a class="header-anchor" href="#q10-threadlocal的原理和使用场景"><span>Q10: ThreadLocal的原理和使用场景？</span></a></h3><p><strong>答：</strong> ThreadLocal为每个线程提供独立的变量副本，实现了线程间的数据隔离。</p><p>原理：</p><ol><li>每个Thread对象内部都有一个ThreadLocalMap</li><li>ThreadLocal作为key，线程本地变量作为value存储在map中</li><li>通过Thread.currentThread()获取当前线程，进而访问其ThreadLocalMap</li></ol><p>使用场景：</p><ol><li>数据库连接管理</li><li>Session管理</li><li>SimpleDateFormat等非线程安全对象的使用</li></ol><h2 id="_5-线程池" tabindex="-1"><a class="header-anchor" href="#_5-线程池"><span>5. 线程池</span></a></h2><h3 id="q11-为什么要使用线程池" tabindex="-1"><a class="header-anchor" href="#q11-为什么要使用线程池"><span>Q11: 为什么要使用线程池？</span></a></h3><p><strong>答：</strong> 使用线程池的好处包括：</p><ol><li><strong>降低资源消耗</strong>：避免频繁创建和销毁线程</li><li><strong>提高响应速度</strong>：任务到达时无需等待线程创建</li><li><strong>提高线程可管理性</strong>：统一分配、调优和监控线程</li><li><strong>防止服务器过载</strong>：通过限制线程数量保护系统</li></ol><h3 id="q12-threadpoolexecutor的核心参数" tabindex="-1"><a class="header-anchor" href="#q12-threadpoolexecutor的核心参数"><span>Q12: ThreadPoolExecutor的核心参数？</span></a></h3><p><strong>答：</strong> ThreadPoolExecutor的构造函数有7个核心参数：</p><ol><li><strong>corePoolSize</strong>：核心线程数，即使空闲也不会被回收</li><li><strong>maximumPoolSize</strong>：最大线程数，线程池中允许的最大线程数</li><li><strong>keepAliveTime</strong>：空闲线程存活时间</li><li><strong>unit</strong>：keepAliveTime的时间单位</li><li><strong>workQueue</strong>：任务队列，用于保存等待执行的任务</li><li><strong>threadFactory</strong>：线程工厂，用于创建新线程</li><li><strong>handler</strong>：拒绝策略，当线程池和队列都满时的处理策略</li></ol><h3 id="q13-线程池的拒绝策略有哪些" tabindex="-1"><a class="header-anchor" href="#q13-线程池的拒绝策略有哪些"><span>Q13: 线程池的拒绝策略有哪些？</span></a></h3><p><strong>答：</strong> Java提供了4种内置的拒绝策略：</p><ol><li><strong>AbortPolicy</strong>：直接抛出RejectedExecutionException异常（默认策略）</li><li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务</li><li><strong>DiscardPolicy</strong>：丢弃不能执行的任务，不抛出异常</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列最前面的任务，然后重新尝试执行</li></ol><h2 id="_6-并发工具类" tabindex="-1"><a class="header-anchor" href="#_6-并发工具类"><span>6. 并发工具类</span></a></h2><h3 id="q14-countdownlatch和cyclicbarrier的区别" tabindex="-1"><a class="header-anchor" href="#q14-countdownlatch和cyclicbarrier的区别"><span>Q14: CountDownLatch和CyclicBarrier的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>CountDownLatch</th><th>CyclicBarrier</th></tr></thead><tbody><tr><td>作用</td><td>一个或多个线程等待其他线程完成操作</td><td>一组线程互相等待到达屏障点</td></tr><tr><td>计数器</td><td>递减计数，不可重用</td><td>递增计数，可重用</td></tr><tr><td>调用方式</td><td>调用countDown()减少计数</td><td>调用await()增加计数</td></tr><tr><td>应用场景</td><td>主线程等待多个子线程完成</td><td>多个线程相互等待</td></tr></tbody></table><h3 id="q15-semaphore的使用场景" tabindex="-1"><a class="header-anchor" href="#q15-semaphore的使用场景"><span>Q15: Semaphore的使用场景？</span></a></h3><p><strong>答：</strong> Semaphore（信号量）用于控制同时访问特定资源的线程数量，常用于：</p><ol><li><strong>流量控制</strong>：限制数据库连接数</li><li><strong>资源访问控制</strong>：限制同时访问某个服务的线程数</li><li><strong>限流</strong>：保护系统免受突发流量冲击</li></ol><p>Semaphore通过acquire()获取许可，release()释放许可来实现资源控制。</p><h2 id="_7-并发集合" tabindex="-1"><a class="header-anchor" href="#_7-并发集合"><span>7. 并发集合</span></a></h2><h3 id="q16-concurrenthashmap如何保证线程安全" tabindex="-1"><a class="header-anchor" href="#q16-concurrenthashmap如何保证线程安全"><span>Q16: ConcurrentHashMap如何保证线程安全？</span></a></h3><p><strong>答：</strong> ConcurrentHashMap保证线程安全的方式随着JDK版本演进而变化：</p><ol><li><strong>JDK 1.7</strong>：采用分段锁（Segment）机制，将数据分成多个段，每段独立加锁</li><li><strong>JDK 1.8</strong>：取消分段锁，采用CAS+synchronized实现： <ul><li>使用CAS操作处理无冲突情况</li><li>冲突时使用synchronized锁定链表或红黑树头节点</li><li>引入红黑树优化大量冲突的情况</li></ul></li></ol><h3 id="q17-copyonwritearraylist的实现原理" tabindex="-1"><a class="header-anchor" href="#q17-copyonwritearraylist的实现原理"><span>Q17: CopyOnWriteArrayList的实现原理？</span></a></h3><p><strong>答：</strong> CopyOnWriteArrayList采用写时复制策略：</p><ol><li>读操作不加锁，直接读取</li><li>写操作时加锁，并复制整个数组</li><li>在新数组上修改，然后将原数组引用指向新数组</li><li>适用于读多写少的场景</li></ol><p>优点：读操作完全无锁，性能高 缺点：写操作成本高，内存占用大</p><h2 id="_8-原子类" tabindex="-1"><a class="header-anchor" href="#_8-原子类"><span>8. 原子类</span></a></h2><h3 id="q18-cas-compare-and-swap-原理" tabindex="-1"><a class="header-anchor" href="#q18-cas-compare-and-swap-原理"><span>Q18: CAS（Compare-And-Swap）原理？</span></a></h3><p><strong>答：</strong> CAS是一种无锁的原子操作，包含三个操作数：</p><ol><li><strong>V</strong>：内存位置</li><li><strong>A</strong>：预期值</li><li><strong>B</strong>：新值</li></ol><p>执行过程：当且仅当V的值等于A时，才用B更新V的值，否则不执行任何操作。</p><p>优点：避免了传统锁的线程阻塞和唤醒开销 缺点：可能出现ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作</p><h3 id="q19-atomicintegerfieldupdater的作用" tabindex="-1"><a class="header-anchor" href="#q19-atomicintegerfieldupdater的作用"><span>Q19: AtomicIntegerFieldUpdater的作用？</span></a></h3><p><strong>答：</strong> AtomicIntegerFieldUpdater是对普通字段进行原子操作的工具类：</p><ol><li>可以对指定类的volatile int字段进行原子更新</li><li>不创建额外对象，节省内存</li><li>使用反射机制实现对字段的原子操作</li></ol><p>适用场景：需要对已有类的字段进行原子操作，而不希望修改类的定义。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><!----><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script src="/wiki/assets/js/runtime~app.46b38a58.js" defer></script><script src="/wiki/assets/js/768.e6d4205d.js" defer></script><script src="/wiki/assets/js/app.6ec2591a.js" defer></script>
  </body>
</html>
