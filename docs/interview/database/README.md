# 数据库面

## 1. 数据库基础

### Q1: 什么是数据库？数据库管理系统有哪些类型？
**答：** 数据库是长期存储在计算机内、有组织的、可共享的数据集合。

数据库管理系统的类型：
1. **关系型数据库（RDBMS）**：
   - MySQL、PostgreSQL、Oracle、SQL Server
   - 基于关系模型，使用SQL语言

2. **非关系型数据库（NoSQL）**：
   - 文档数据库：MongoDB、CouchDB
   - 键值数据库：Redis、DynamoDB
   - 列族数据库：Cassandra、HBase
   - 图数据库：Neo4j、Amazon Neptune

### Q2: SQL和NoSQL的区别？
**答：**

| 特性 | SQL | NoSQL |
|------|-----|-------|
| 数据结构 | 结构化表格 | 灵活的数据模型 |
| 查询语言 | SQL | 多样化API |
| 扩展性 | 垂直扩展 | 水平扩展 |
| ACID特性 | 完全支持 | 部分支持 |
| 事务支持 | 强事务支持 | 弱事务支持 |
| 适用场景 | 复杂查询、事务处理 | 大数据、高并发 |

### Q3: 数据库范式是什么？有哪些常见的范式？
**答：** 数据库范式是数据库设计的规范，目的是减少数据冗余和提高数据一致性。

常见范式：
1. **第一范式（1NF）**：字段不可再分，每个字段都是原子性的
2. **第二范式（2NF）**：满足1NF，非主键字段完全依赖主键
3. **第三范式（3NF）**：满足2NF，非主键字段不依赖其他非主键字段
4. **BCNF范式**：满足3NF，消除主属性对候选键的部分和传递依赖

## 2. MySQL

### Q4: MySQL的存储引擎有哪些？有什么区别？
**答：** MySQL常见的存储引擎：

1. **InnoDB**：
   - 默认存储引擎
   - 支持事务、外键、行级锁
   - 支持崩溃恢复
   - 适合高并发读写

2. **MyISAM**：
   - 不支持事务和外键
   - 表级锁
   - 查询速度快
   - 适合读多写少的场景

3. **Memory**：
   - 数据存储在内存中
   - 速度快但不稳定
   - 适合临时表

### Q5: InnoDB和MyISAM的区别？
**答：**

| 特性 | InnoDB | MyISAM |
|------|--------|--------|
| 事务支持 | 支持 | 不支持 |
| 锁机制 | 行级锁 | 表级锁 |
| 外键支持 | 支持 | 不支持 |
| 崩溃恢复 | 支持 | 不支持 |
| 存储结构 | 聚簇索引 | 非聚簇索引 |
| 查询性能 | 一般 | 较好 |
| 插入性能 | 较好 | 好 |
| 缓存机制 | 缓存索引和数据 | 只缓存索引 |

### Q6: MySQL的索引类型有哪些？
**答：** MySQL的索引类型：

1. **主键索引（Primary Key）**：唯一标识，不允许重复和NULL
2. **唯一索引（Unique）**：索引列的值必须唯一，允许NULL
3. **普通索引（Index）**：最基本的索引，没有任何限制
4. **全文索引（Fulltext）**：用于全文搜索
5. **组合索引**：多个字段组成的索引
6. **前缀索引**：对字段前缀建立索引

按数据结构分类：
- B+树索引（默认）
- Hash索引（Memory引擎）
- R-Tree索引（空间索引）

## 3. 索引优化

### Q7: 什么是索引？索引的优缺点？
**答：** 索引是数据库中用于提高数据检索速度的数据结构。

**优点：**
- 提高查询速度
- 加速表与表之间的连接
- 保证数据的唯一性

**缺点：**
- 占用磁盘空间
- 影响插入、更新、删除速度
- 维护索引需要成本

### Q8: 如何优化索引？
**答：** 索引优化的方法：

1. **选择合适的字段建立索引**：
   - 经常用于WHERE条件的字段
   - 经常用于ORDER BY的字段
   - 经常用于JOIN的字段

2. **组合索引优化**：
   - 遵循最左前缀原则
   - 将区分度高的字段放在前面

3. **避免索引失效**：
   - 避免在索引字段上使用函数
   - 避免类型隐式转换
   - 避免使用!=或<>操作符

4. **定期维护索引**：
   - 删除不用的索引
   - 重建碎片化严重的索引

### Q9: 什么是覆盖索引？有什么好处？
**答：** 覆盖索引是指查询的所有字段都在索引中，不需要回表查询。

好处：
- 减少IO操作
- 提高查询性能
- 减少数据访问量

示例：
```sql
-- 假设有索引 idx_name_age(name, age)
SELECT name, age FROM user WHERE name = 'John';
-- 这个查询可以使用覆盖索引
```

## 4. 事务和锁

### Q10: 什么是事务？ACID特性是什么？
**答：** 事务是数据库操作的逻辑单位，由一系列操作组成。

ACID特性：
1. **Atomicity（原子性）**：事务要么全部成功，要么全部失败
2. **Consistency（一致性）**：事务执行前后数据保持一致状态
3. **Isolation（隔离性）**：并发事务之间相互隔离
4. **Durability（持久性）**：事务提交后数据永久保存

### Q11: 事务的隔离级别有哪些？
**答：** SQL标准定义了四种隔离级别：

1. **READ UNCOMMITTED（读未提交）**：
   - 最低隔离级别
   - 可能出现脏读、不可重复读、幻读

2. **READ COMMITTED（读已提交）**：
   - Oracle默认级别
   - 避免脏读，可能出现不可重复读、幻读

3. **REPEATABLE READ（可重复读）**：
   - MySQL默认级别
   - 避免脏读、不可重复读，可能出现幻读

4. **SERIALIZABLE（串行化）**：
   - 最高隔离级别
   - 避免所有并发问题，性能最差

### Q12: 什么是MVCC？如何实现？
**答：** MVCC（Multi-Version Concurrency Control）多版本并发控制，是数据库并发控制的一种方法。

实现原理：
- 每行记录有两个隐藏字段：创建版本号和删除版本号
- 事务开始时获得系统版本号
- SELECT：只查找版本号小于等于当前事务版本号的记录
- INSERT：插入新记录，创建版本号为当前事务版本号
- DELETE：删除记录，删除版本号为当前事务版本号
- UPDATE：先删除旧记录，再插入新记录

## 5. 锁机制

### Q13: MySQL的锁有哪些类型？
**答：** MySQL的锁类型：

1. **按锁粒度分类**：
   - 表级锁：开销小，加锁快，冲突概率高
   - 行级锁：开销大，加锁慢，冲突概率低
   - 页级锁：介于表级锁和行级锁之间

2. **按锁类型分类**：
   - 共享锁（S锁）：读锁，允许多个事务同时读
   - 排他锁（X锁）：写锁，阻止其他事务读写

3. **按思想分类**：
   - 悲观锁：认为会发生并发冲突，先加锁
   - 乐观锁：认为不会发生并发冲突，使用版本号控制

### Q14: 什么是死锁？如何避免？
**答：** 死锁是指两个或多个事务在执行过程中因争夺资源而造成的一种互相等待的现象。

避免死锁的方法：
1. **按相同顺序访问资源**：统一加锁顺序
2. **缩短事务持有锁的时间**：减少事务执行时间
3. **降低隔离级别**：使用较低的隔离级别
4. **使用索引**：避免全表扫描导致的锁升级
5. **设置超时时间**：设置锁等待超时时间

### Q15: 乐观锁和悲观锁的区别？
**答：**

| 特性 | 乐观锁 | 悲观锁 |
|------|--------|--------|
| 思想 | 认为不会发生并发冲突 | 认为会发生并发冲突 |
| 实现方式 | 版本号、时间戳 | 数据库锁机制 |
| 适用场景 | 读多写少 | 写多读少 |
| 性能 | 高并发性能好 | 并发性能较差 |
| 冲突处理 | 失败后重试 | 等待锁释放 |

## 6. SQL优化

### Q16: 如何优化SQL查询？
**答：** SQL查询优化的方法：

1. **使用索引**：
   - 为WHERE、ORDER BY、JOIN字段建立索引
   - 避免索引失效

2. **优化查询语句**：
   - 避免SELECT *
   - 使用LIMIT分页
   - 避免子查询，使用JOIN替代

3. **表结构优化**：
   - 合理设计表结构
   - 适当的字段类型
   - 规范化与反规范化平衡

4. **查询计划分析**：
   - 使用EXPLAIN分析查询计划
   - 识别性能瓶颈

### Q17: EXPLAIN的含义？
**答：** EXPLAIN用于分析SQL语句的执行计划。

主要字段含义：
- **id**：查询序列号
- **select_type**：查询类型（SIMPLE、PRIMARY、SUBQUERY等）
- **table**：表名
- **partitions**：匹配的分区
- **type**：连接类型（system、const、eq_ref、ref、range、index、ALL）
- **possible_keys**：可能使用的索引
- **key**：实际使用的索引
- **key_len**：索引长度
- **ref**：索引比较的列
- **rows**：扫描的行数
- **filtered**：过滤百分比
- **Extra**：额外信息

### Q18: 什么是慢查询？如何优化？
**答：** 慢查询是指执行时间超过指定阈值的SQL语句。

优化方法：
1. **开启慢查询日志**：
   ```sql
   SET GLOBAL slow_query_log = 'ON';
   SET GLOBAL long_query_time = 2;
   ```

2. **分析慢查询日志**：
   - 使用mysqldumpslow工具分析
   - 识别执行频率高、耗时长的SQL

3. **优化措施**：
   - 添加合适的索引
   - 重写SQL语句
   - 分析执行计划
   - 考虑分库分表

## 7. 数据库设计

### Q19: 数据库设计的原则？
**答：** 数据库设计的原则：

1. **规范化原则**：
   - 遵循数据库范式
   - 减少数据冗余

2. **性能原则**：
   - 平衡规范化与性能
   - 合理使用索引

3. **扩展性原则**：
   - 考虑未来业务发展
   - 预留扩展空间

4. **安全性原则**：
   - 数据安全
   - 访问控制

5. **一致性原则**：
   - 数据完整性和一致性
   - 使用约束和触发器

### Q20: 分库分表的策略？
**答：** 分库分表的策略：

1. **垂直分库**：
   - 按业务模块拆分
   - 不同业务模块存储在不同数据库

2. **水平分库**：
   - 按数据范围拆分
   - 不同范围的数据存储在不同数据库

3. **垂直分表**：
   - 按字段拆分
   - 热字段和冷字段分离

4. **水平分表**：
   - 按某种规则拆分数据
   - 如按用户ID取模、按时间范围等

分库分表的挑战：
- 分布式事务
- 跨库查询
- 数据迁移
- ID生成策略
- 分页查询复杂
