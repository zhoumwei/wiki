# Java 集合框架详解

## 1. 集合框架概述

### Q1: 什么是Java集合框架？
**答：** Java集合框架是Java提供的用于存储和操作一组对象的数据结构。它包含了一系列接口、实现类和算法，能够高效地处理数据集合。

主要优势：
- 减少编程工作量
- 提高程序速度和质量
- 允许互操作性
- 提供丰富的API

### Q2: Java集合框架包含哪些核心接口？
**答：** Java集合框架的核心接口包括：

1. **Collection**：集合层次结构的根接口
   - **List**：有序集合，允许重复元素
   - **Set**：不允许重复元素的集合
   - **Queue**：队列接口，通常以FIFO方式排列元素

2. **Map**：将键映射到值的对象，键不能重复

### Q3: Collection和Collections有什么区别？
**答：**
- **Collection**：是一个接口，是集合框架的根接口
- **Collections**：是一个工具类，提供了大量操作集合的静态方法，如排序、查找、同步等

## 2. List接口及其实现类

### Q4: ArrayList和LinkedList的区别？
**答：**
| 特性 | ArrayList | LinkedList |
|------|-----------|------------|
| 底层实现 | 动态数组 | 双向链表 |
| 查询效率 | O(1) | O(n) |
| 插入/删除效率 | O(n) | O(1) |
| 内存占用 | 较少 | 较多 |
| 线程安全 | 否 | 否 |

### Q5: Vector和ArrayList的区别？
**答：**
- **Vector**：线程安全，性能较低，扩容为原来的2倍
- **ArrayList**：非线程安全，性能较高，扩容为原来的1.5倍

### Q6: 如何选择合适的List实现？
**答：**
- 需要频繁查询元素：选择ArrayList
- 需要频繁插入/删除元素：选择LinkedList
- 需要线程安全：选择Vector或者使用Collections.synchronizedList()

## 3. Set接口及其实现类

### Q7: HashSet、LinkedHashSet和TreeSet的区别？
**答：**
| 特性 | HashSet | LinkedHashSet | TreeSet |
|------|---------|---------------|---------|
| 存储结构 | 哈希表 | 哈希表+链表 | 红黑树 |
| 有序性 | 无序 | 有序（插入顺序） | 有序（自然排序或自定义排序） |
| 性能 | 最好 | 中等 | 较差 |
| null值 | 允许一个null | 允许一个null | 不允许null |

### Q8: HashSet如何保证元素唯一性？
**答：** HashSet通过以下方式保证元素唯一性：
1. 调用元素的hashCode()方法获取哈希码
2. 通过哈希码确定元素在哈希表中的存储位置
3. 如果该位置没有元素，则直接存储
4. 如果该位置有元素，则调用equals()方法比较
5. 如果equals()返回true，则认为是重复元素，不存储
6. 如果equals()返回false，则发生哈希冲突，采用链表或红黑树解决

## 4. Map接口及其实现类

### Q9: HashMap和Hashtable的区别？
**答：**
| 特性 | HashMap | Hashtable |
|------|---------|-----------|
| 线程安全 | 否 | 是 |
| null值 | 允许null键和null值 | 不允许null键和null值 |
| 继承关系 | 继承AbstractMap | 继承Dictionary |
| 扩容方式 | 2倍 | 2倍+1 |
| 迭代器 | 快速失败迭代器 | 枚举Enumeration |

### Q10: ConcurrentHashMap的实现原理？
**答：** ConcurrentHashMap采用了以下技术来保证高性能和线程安全：
1. **分段锁（JDK 1.7）**：将数据分成多个Segment，每个Segment独立加锁
2. **CAS+Synchronized（JDK 1.8）**：使用CAS操作处理无冲突情况，冲突时使用synchronized锁定头节点
3. **Node+ForwardingNode**：Node表示普通节点，ForwardingNode表示正在扩容的节点

### Q11: HashMap的工作原理？
**答：** HashMap的工作原理如下：
1. 通过key的hashCode()方法计算hash值
2. 通过hash值和数组长度计算出索引位置
3. 如果该位置没有元素，则直接插入
4. 如果该位置有元素，则判断key是否相等
5. 如果key相等则覆盖原值
6. 如果key不相等则形成链表（JDK 8以后超过阈值会转为红黑树）

### Q12: HashMap在JDK 8中链表转红黑树的详解？
**答：** 在JDK 8中，HashMap引入了一个重要的优化机制：当链表长度超过一定阈值时，会将链表转换为红黑树，以提高查找效率。

**转换条件：**
1. 链表长度达到阈值（默认为8）
2. 数组长度达到最小值（默认为64）

**为什么要转换为红黑树？**
- 链表查找时间复杂度为O(n)，当链表过长时性能较差
- 红黑树查找时间复杂度为O(log n)，在链表较长时能显著提升性能

**转换过程：**
1. 当链表长度达到8时，会触发树化操作
2. 但在数组长度小于64时，会优先选择扩容而不是树化
3. 只有当数组长度大于等于64且链表长度达到8时，才会真正执行树化操作

**红黑树的特点：**
- 每个节点要么是红色，要么是黑色
- 根节点是黑色
- 每个叶子节点（NIL节点）是黑色
- 不能有相邻的两个红色节点
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

**反向转换：**
- 当红黑树节点数量减少到6个或以下时，会转换回链表
- 这样可以避免在节点较少时维护红黑树结构的开销

**性能对比：**
- 链表：查找O(n)，插入O(1)
- 红黑树：查找O(log n)，插入O(log n)

这种设计在保证大多数情况下插入效率的同时，优化了极端情况下的查找性能。

### Q13: Queue接口有哪些常用方法？
**答：** Queue接口的常用方法分为两组：
1. **抛出异常的方法**：
   - add(e)：插入元素，队列满时抛出异常
   - remove()：移除并返回头部元素，队列空时抛出异常
   - element()：返回头部元素但不移除，队列空时抛出异常

2. **返回特殊值的方法**：
   - offer(e)：插入元素，队列满时返回false
   - poll()：移除并返回头部元素，队列空时返回null
   - peek()：返回头部元素但不移除，队列空时返回null

### Q14: PriorityQueue的实现原理？
**答：** PriorityQueue是基于优先堆的无限优先队列：
1. 使用完全二叉树结构存储元素
2. 默认是最小堆，即最小元素总是在队首
3. 插入元素时通过上浮操作维护堆性质
4. 删除元素时通过下沉操作维护堆性质
5. 时间复杂度：插入O(log n)，删除O(log n)，查看O(1)