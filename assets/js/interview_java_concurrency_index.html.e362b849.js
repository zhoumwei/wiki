"use strict";(self.webpackChunkmy_vuepress_site=self.webpackChunkmy_vuepress_site||[]).push([[275],{474:(n,a,s)=>{s.r(a),s.d(a,{comp:()=>l,data:()=>i});var e=s(641);const t={},l=(0,s(6262).A)(t,[["render",function(n,a){return(0,e.uX)(),(0,e.CE)("div",null,[...a[0]||(a[0]=[(0,e.Fv)('<h1 id="java-多线程详解" tabindex="-1"><a class="header-anchor" href="#java-多线程详解"><span>Java 多线程详解</span></a></h1><h2 id="_1-线程基础概念" tabindex="-1"><a class="header-anchor" href="#_1-线程基础概念"><span>1. 线程基础概念</span></a></h2><h3 id="q1-什么是进程和线程" tabindex="-1"><a class="header-anchor" href="#q1-什么是进程和线程"><span>Q1: 什么是进程和线程？</span></a></h3><p><strong>答：</strong></p><ul><li><strong>进程</strong>：是操作系统分配资源的基本单位，每个进程都有独立的内存空间</li><li><strong>线程</strong>：是CPU调度的基本单位，同一进程内的线程共享进程的内存空间</li></ul><p>主要区别：</p><ol><li>地址空间：进程间相互独立，线程间共享所属进程的资源</li><li>开销：进程创建和销毁开销大，线程相对较小</li><li>切换：进程切换开销大，线程切换开销小</li><li>通信：进程间通信需要IPC机制，线程间可直接读写进程数据</li></ol><h3 id="q2-为什么要使用多线程" tabindex="-1"><a class="header-anchor" href="#q2-为什么要使用多线程"><span>Q2: 为什么要使用多线程？</span></a></h3><p><strong>答：</strong> 使用多线程的主要原因包括：</p><ol><li><strong>提高性能</strong>：充分利用多核CPU的计算能力</li><li><strong>改善用户体验</strong>：避免界面卡顿，提升响应速度</li><li><strong>提高资源利用率</strong>：当一个线程等待I/O时，其他线程可以继续执行</li><li><strong>简化程序设计</strong>：某些业务逻辑天然适合并发处理</li></ol><h3 id="q3-线程有哪些状态" tabindex="-1"><a class="header-anchor" href="#q3-线程有哪些状态"><span>Q3: 线程有哪些状态？</span></a></h3><p><strong>答：</strong> Java线程有6种状态：</p><ol><li><strong>NEW</strong>：新建状态，线程刚创建还未调用start()方法</li><li><strong>RUNNABLE</strong>：就绪状态，线程正在JVM中执行，可能正在等待OS资源（如处理器）</li><li><strong>BLOCKED</strong>：阻塞状态，线程等待监视器锁进入同步块/方法</li><li><strong>WAITING</strong>：等待状态，线程无限期等待其他线程执行特定动作</li><li><strong>TIMED_WAITING</strong>：超时等待状态，线程等待其他线程执行特定动作，但设置了超时时间</li><li><strong>TERMINATED</strong>：终止状态，线程执行完毕</li></ol><h2 id="_2-创建线程的方式" tabindex="-1"><a class="header-anchor" href="#_2-创建线程的方式"><span>2. 创建线程的方式</span></a></h2><h3 id="q4-创建线程有哪几种方式" tabindex="-1"><a class="header-anchor" href="#q4-创建线程有哪几种方式"><span>Q4: 创建线程有哪几种方式？</span></a></h3><p><strong>答：</strong> 创建线程主要有以下几种方式：</p><ol><li><p><strong>继承Thread类</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span></span>\n<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">        <span class="token comment">// 线程执行代码</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"><span class="token comment">// 使用</span></span>\n<span class="line"><span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>实现Runnable接口</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span></span>\n<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">        <span class="token comment">// 线程执行代码</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"><span class="token comment">// 使用</span></span>\n<span class="line"><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>实现Callable接口</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>\n<span class="line">    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span></span>\n<span class="line">        <span class="token comment">// 线程执行代码，有返回值</span></span>\n<span class="line">        <span class="token keyword">return</span> <span class="token string">&quot;执行结果&quot;</span><span class="token punctuation">;</span></span>\n<span class="line">    <span class="token punctuation">}</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"><span class="token comment">// 使用</span></span>\n<span class="line"><span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>使用线程池</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>\n<span class="line">    <span class="token comment">// 线程执行代码</span></span>\n<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="q5-runnable和callable的区别" tabindex="-1"><a class="header-anchor" href="#q5-runnable和callable的区别"><span>Q5: Runnable和Callable的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>Runnable</th><th>Callable</th></tr></thead><tbody><tr><td>返回值</td><td>无返回值</td><td>有返回值</td></tr><tr><td>异常处理</td><td>不能抛出受检异常</td><td>可以抛出受检异常</td></tr><tr><td>实现方法</td><td>run()</td><td>call()</td></tr><tr><td>使用场景</td><td>一般任务执行</td><td>有返回结果的任务</td></tr></tbody></table><h2 id="_3-线程同步与锁机制" tabindex="-1"><a class="header-anchor" href="#_3-线程同步与锁机制"><span>3. 线程同步与锁机制</span></a></h2><h3 id="q6-synchronized关键字的作用和用法" tabindex="-1"><a class="header-anchor" href="#q6-synchronized关键字的作用和用法"><span>Q6: synchronized关键字的作用和用法？</span></a></h3><p><strong>答：</strong> synchronized关键字用于实现线程同步，确保同一时刻只有一个线程执行特定代码块。</p><p>用法：</p><ol><li><p><strong>修饰实例方法</strong>：锁住当前实例对象</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 代码 */</span> <span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>修饰静态方法</strong>：锁住当前类的Class对象</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 代码 */</span> <span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>修饰代码块</strong>：指定加锁对象</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 代码 */</span> <span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><h3 id="q7-volatile关键字的作用" tabindex="-1"><a class="header-anchor" href="#q7-volatile关键字的作用"><span>Q7: volatile关键字的作用？</span></a></h3><p><strong>答：</strong> volatile关键字有两个主要作用：</p><ol><li><strong>可见性</strong>：确保变量修改对所有线程立即可见</li><li><strong>禁止指令重排序</strong>：防止JVM对代码进行优化重排序</li></ol><p>注意：volatile不能保证原子性，只保证可见性和有序性。</p><h3 id="q8-reentrantlock和synchronized的区别" tabindex="-1"><a class="header-anchor" href="#q8-reentrantlock和synchronized的区别"><span>Q8: ReentrantLock和synchronized的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>ReentrantLock</th><th>synchronized</th></tr></thead><tbody><tr><td>锁获取方式</td><td>显式获取和释放</td><td>隐式获取和释放</td></tr><tr><td>可中断</td><td>支持</td><td>不支持</td></tr><tr><td>超时获取</td><td>支持</td><td>不支持</td></tr><tr><td>公平锁</td><td>支持</td><td>不支持</td></tr><tr><td>锁绑定条件</td><td>支持多个Condition</td><td>不支持</td></tr><tr><td>性能</td><td>竞争激烈时表现更好</td><td>竞争不激烈时性能较好</td></tr></tbody></table><h2 id="_4-线程间通信" tabindex="-1"><a class="header-anchor" href="#_4-线程间通信"><span>4. 线程间通信</span></a></h2><h3 id="q9-wait-、notify-和notifyall-的作用" tabindex="-1"><a class="header-anchor" href="#q9-wait-、notify-和notifyall-的作用"><span>Q9: wait()、notify()和notifyAll()的作用？</span></a></h3><p><strong>答：</strong></p><ul><li><strong>wait()</strong>：使当前线程等待并释放锁，直到其他线程调用notify()或notifyAll()</li><li><strong>notify()</strong>：唤醒在此对象监视器上等待的单个线程</li><li><strong>notifyAll()</strong>：唤醒在此对象监视器上等待的所有线程</li></ul><p>注意事项：</p><ol><li>这些方法只能在同步方法或同步块中调用</li><li>调用wait()后线程会释放锁，而sleep()不会释放锁</li><li>通常使用while循环而不是if语句来检查条件</li></ol><h3 id="q10-threadlocal的原理和使用场景" tabindex="-1"><a class="header-anchor" href="#q10-threadlocal的原理和使用场景"><span>Q10: ThreadLocal的原理和使用场景？</span></a></h3><p><strong>答：</strong> ThreadLocal为每个线程提供独立的变量副本，实现了线程间的数据隔离。</p><p>原理：</p><ol><li>每个Thread对象内部都有一个ThreadLocalMap</li><li>ThreadLocal作为key，线程本地变量作为value存储在map中</li><li>通过Thread.currentThread()获取当前线程，进而访问其ThreadLocalMap</li></ol><p>使用场景：</p><ol><li>数据库连接管理</li><li>Session管理</li><li>SimpleDateFormat等非线程安全对象的使用</li></ol><h2 id="_5-线程池" tabindex="-1"><a class="header-anchor" href="#_5-线程池"><span>5. 线程池</span></a></h2><h3 id="q11-为什么要使用线程池" tabindex="-1"><a class="header-anchor" href="#q11-为什么要使用线程池"><span>Q11: 为什么要使用线程池？</span></a></h3><p><strong>答：</strong> 使用线程池的好处包括：</p><ol><li><strong>降低资源消耗</strong>：避免频繁创建和销毁线程</li><li><strong>提高响应速度</strong>：任务到达时无需等待线程创建</li><li><strong>提高线程可管理性</strong>：统一分配、调优和监控线程</li><li><strong>防止服务器过载</strong>：通过限制线程数量保护系统</li></ol><h3 id="q12-threadpoolexecutor的核心参数" tabindex="-1"><a class="header-anchor" href="#q12-threadpoolexecutor的核心参数"><span>Q12: ThreadPoolExecutor的核心参数？</span></a></h3><p><strong>答：</strong> ThreadPoolExecutor的构造函数有7个核心参数：</p><ol><li><strong>corePoolSize</strong>：核心线程数，即使空闲也不会被回收</li><li><strong>maximumPoolSize</strong>：最大线程数，线程池中允许的最大线程数</li><li><strong>keepAliveTime</strong>：空闲线程存活时间</li><li><strong>unit</strong>：keepAliveTime的时间单位</li><li><strong>workQueue</strong>：任务队列，用于保存等待执行的任务</li><li><strong>threadFactory</strong>：线程工厂，用于创建新线程</li><li><strong>handler</strong>：拒绝策略，当线程池和队列都满时的处理策略</li></ol><h3 id="q13-线程池的拒绝策略有哪些" tabindex="-1"><a class="header-anchor" href="#q13-线程池的拒绝策略有哪些"><span>Q13: 线程池的拒绝策略有哪些？</span></a></h3><p><strong>答：</strong> Java提供了4种内置的拒绝策略：</p><ol><li><strong>AbortPolicy</strong>：直接抛出RejectedExecutionException异常（默认策略）</li><li><strong>CallerRunsPolicy</strong>：由调用线程处理该任务</li><li><strong>DiscardPolicy</strong>：丢弃不能执行的任务，不抛出异常</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列最前面的任务，然后重新尝试执行</li></ol><h2 id="_6-并发工具类" tabindex="-1"><a class="header-anchor" href="#_6-并发工具类"><span>6. 并发工具类</span></a></h2><h3 id="q14-countdownlatch和cyclicbarrier的区别" tabindex="-1"><a class="header-anchor" href="#q14-countdownlatch和cyclicbarrier的区别"><span>Q14: CountDownLatch和CyclicBarrier的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>CountDownLatch</th><th>CyclicBarrier</th></tr></thead><tbody><tr><td>作用</td><td>一个或多个线程等待其他线程完成操作</td><td>一组线程互相等待到达屏障点</td></tr><tr><td>计数器</td><td>递减计数，不可重用</td><td>递增计数，可重用</td></tr><tr><td>调用方式</td><td>调用countDown()减少计数</td><td>调用await()增加计数</td></tr><tr><td>应用场景</td><td>主线程等待多个子线程完成</td><td>多个线程相互等待</td></tr></tbody></table><h3 id="q15-semaphore的使用场景" tabindex="-1"><a class="header-anchor" href="#q15-semaphore的使用场景"><span>Q15: Semaphore的使用场景？</span></a></h3><p><strong>答：</strong> Semaphore（信号量）用于控制同时访问特定资源的线程数量，常用于：</p><ol><li><strong>流量控制</strong>：限制数据库连接数</li><li><strong>资源访问控制</strong>：限制同时访问某个服务的线程数</li><li><strong>限流</strong>：保护系统免受突发流量冲击</li></ol><p>Semaphore通过acquire()获取许可，release()释放许可来实现资源控制。</p><h2 id="_7-并发集合" tabindex="-1"><a class="header-anchor" href="#_7-并发集合"><span>7. 并发集合</span></a></h2><h3 id="q16-concurrenthashmap如何保证线程安全" tabindex="-1"><a class="header-anchor" href="#q16-concurrenthashmap如何保证线程安全"><span>Q16: ConcurrentHashMap如何保证线程安全？</span></a></h3><p><strong>答：</strong> ConcurrentHashMap保证线程安全的方式随着JDK版本演进而变化：</p><ol><li><strong>JDK 1.7</strong>：采用分段锁（Segment）机制，将数据分成多个段，每段独立加锁</li><li><strong>JDK 1.8</strong>：取消分段锁，采用CAS+synchronized实现： <ul><li>使用CAS操作处理无冲突情况</li><li>冲突时使用synchronized锁定链表或红黑树头节点</li><li>引入红黑树优化大量冲突的情况</li></ul></li></ol><h3 id="q17-copyonwritearraylist的实现原理" tabindex="-1"><a class="header-anchor" href="#q17-copyonwritearraylist的实现原理"><span>Q17: CopyOnWriteArrayList的实现原理？</span></a></h3><p><strong>答：</strong> CopyOnWriteArrayList采用写时复制策略：</p><ol><li>读操作不加锁，直接读取</li><li>写操作时加锁，并复制整个数组</li><li>在新数组上修改，然后将原数组引用指向新数组</li><li>适用于读多写少的场景</li></ol><p>优点：读操作完全无锁，性能高 缺点：写操作成本高，内存占用大</p><h2 id="_8-原子类" tabindex="-1"><a class="header-anchor" href="#_8-原子类"><span>8. 原子类</span></a></h2><h3 id="q18-cas-compare-and-swap-原理" tabindex="-1"><a class="header-anchor" href="#q18-cas-compare-and-swap-原理"><span>Q18: CAS（Compare-And-Swap）原理？</span></a></h3><p><strong>答：</strong> CAS是一种无锁的原子操作，包含三个操作数：</p><ol><li><strong>V</strong>：内存位置</li><li><strong>A</strong>：预期值</li><li><strong>B</strong>：新值</li></ol><p>执行过程：当且仅当V的值等于A时，才用B更新V的值，否则不执行任何操作。</p><p>优点：避免了传统锁的线程阻塞和唤醒开销 缺点：可能出现ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作</p><h3 id="q19-atomicintegerfieldupdater的作用" tabindex="-1"><a class="header-anchor" href="#q19-atomicintegerfieldupdater的作用"><span>Q19: AtomicIntegerFieldUpdater的作用？</span></a></h3><p><strong>答：</strong> AtomicIntegerFieldUpdater是对普通字段进行原子操作的工具类：</p><ol><li>可以对指定类的volatile int字段进行原子更新</li><li>不创建额外对象，节省内存</li><li>使用反射机制实现对字段的原子操作</li></ol><p>适用场景：需要对已有类的字段进行原子操作，而不希望修改类的定义。</p>',80)])])}]]),i=JSON.parse('{"path":"/interview/java/concurrency/","title":"Java 多线程详解","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"1. 线程基础概念","slug":"_1-线程基础概念","link":"#_1-线程基础概念","children":[{"level":3,"title":"Q1: 什么是进程和线程？","slug":"q1-什么是进程和线程","link":"#q1-什么是进程和线程","children":[]},{"level":3,"title":"Q2: 为什么要使用多线程？","slug":"q2-为什么要使用多线程","link":"#q2-为什么要使用多线程","children":[]},{"level":3,"title":"Q3: 线程有哪些状态？","slug":"q3-线程有哪些状态","link":"#q3-线程有哪些状态","children":[]}]},{"level":2,"title":"2. 创建线程的方式","slug":"_2-创建线程的方式","link":"#_2-创建线程的方式","children":[{"level":3,"title":"Q4: 创建线程有哪几种方式？","slug":"q4-创建线程有哪几种方式","link":"#q4-创建线程有哪几种方式","children":[]},{"level":3,"title":"Q5: Runnable和Callable的区别？","slug":"q5-runnable和callable的区别","link":"#q5-runnable和callable的区别","children":[]}]},{"level":2,"title":"3. 线程同步与锁机制","slug":"_3-线程同步与锁机制","link":"#_3-线程同步与锁机制","children":[{"level":3,"title":"Q6: synchronized关键字的作用和用法？","slug":"q6-synchronized关键字的作用和用法","link":"#q6-synchronized关键字的作用和用法","children":[]},{"level":3,"title":"Q7: volatile关键字的作用？","slug":"q7-volatile关键字的作用","link":"#q7-volatile关键字的作用","children":[]},{"level":3,"title":"Q8: ReentrantLock和synchronized的区别？","slug":"q8-reentrantlock和synchronized的区别","link":"#q8-reentrantlock和synchronized的区别","children":[]}]},{"level":2,"title":"4. 线程间通信","slug":"_4-线程间通信","link":"#_4-线程间通信","children":[{"level":3,"title":"Q9: wait()、notify()和notifyAll()的作用？","slug":"q9-wait-、notify-和notifyall-的作用","link":"#q9-wait-、notify-和notifyall-的作用","children":[]},{"level":3,"title":"Q10: ThreadLocal的原理和使用场景？","slug":"q10-threadlocal的原理和使用场景","link":"#q10-threadlocal的原理和使用场景","children":[]}]},{"level":2,"title":"5. 线程池","slug":"_5-线程池","link":"#_5-线程池","children":[{"level":3,"title":"Q11: 为什么要使用线程池？","slug":"q11-为什么要使用线程池","link":"#q11-为什么要使用线程池","children":[]},{"level":3,"title":"Q12: ThreadPoolExecutor的核心参数？","slug":"q12-threadpoolexecutor的核心参数","link":"#q12-threadpoolexecutor的核心参数","children":[]},{"level":3,"title":"Q13: 线程池的拒绝策略有哪些？","slug":"q13-线程池的拒绝策略有哪些","link":"#q13-线程池的拒绝策略有哪些","children":[]}]},{"level":2,"title":"6. 并发工具类","slug":"_6-并发工具类","link":"#_6-并发工具类","children":[{"level":3,"title":"Q14: CountDownLatch和CyclicBarrier的区别？","slug":"q14-countdownlatch和cyclicbarrier的区别","link":"#q14-countdownlatch和cyclicbarrier的区别","children":[]},{"level":3,"title":"Q15: Semaphore的使用场景？","slug":"q15-semaphore的使用场景","link":"#q15-semaphore的使用场景","children":[]}]},{"level":2,"title":"7. 并发集合","slug":"_7-并发集合","link":"#_7-并发集合","children":[{"level":3,"title":"Q16: ConcurrentHashMap如何保证线程安全？","slug":"q16-concurrenthashmap如何保证线程安全","link":"#q16-concurrenthashmap如何保证线程安全","children":[]},{"level":3,"title":"Q17: CopyOnWriteArrayList的实现原理？","slug":"q17-copyonwritearraylist的实现原理","link":"#q17-copyonwritearraylist的实现原理","children":[]}]},{"level":2,"title":"8. 原子类","slug":"_8-原子类","link":"#_8-原子类","children":[{"level":3,"title":"Q18: CAS（Compare-And-Swap）原理？","slug":"q18-cas-compare-and-swap-原理","link":"#q18-cas-compare-and-swap-原理","children":[]},{"level":3,"title":"Q19: AtomicIntegerFieldUpdater的作用？","slug":"q19-atomicintegerfieldupdater的作用","link":"#q19-atomicintegerfieldupdater的作用","children":[]}]}],"git":{"contributors":[{"name":"mingwzh","username":"mingwzh","email":"1127699551@qq.com","commits":2,"url":"https://github.com/mingwzh"}],"changelog":[{"hash":"edcc4607236c9c3fadfdc41679803e361a1b9d5e","time":1768012480000,"email":"1127699551@qq.com","author":"mingwzh","message":"docs(config): 关闭页面最后更新时间和贡献者显示"},{"hash":"b0045dda273a195bd7df47269121fca343a80b10","time":1766389396000,"email":"1127699551@qq.com","author":"mingwzh","message":"feat(docs): add detailed Java interview notes and update sidebar config"}]},"filePathRelative":"interview/java/concurrency/README.md"}')}}]);