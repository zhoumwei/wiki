"use strict";(self.webpackChunkmy_vuepress_site=self.webpackChunkmy_vuepress_site||[]).push([[248],{281:(l,i,n)=>{n.r(i),n.d(i,{comp:()=>s,data:()=>o});var r=n(641);const t={},s=(0,n(6262).A)(t,[["render",function(l,i){return(0,r.uX)(),(0,r.CE)("div",null,[...i[0]||(i[0]=[(0,r.Fv)('<h1 id="消息队列面试题" tabindex="-1"><a class="header-anchor" href="#消息队列面试题"><span>消息队列面试题</span></a></h1><h2 id="_1-消息队列基础" tabindex="-1"><a class="header-anchor" href="#_1-消息队列基础"><span>1. 消息队列基础</span></a></h2><h3 id="q1-什么是消息队列-它解决了什么问题" tabindex="-1"><a class="header-anchor" href="#q1-什么是消息队列-它解决了什么问题"><span>Q1: 什么是消息队列？它解决了什么问题？</span></a></h3><p><strong>答：</strong> 消息队列是一种在分布式系统中进行异步通信的中间件，用于在应用程序之间传递消息。</p><p>解决的问题：</p><ol><li><strong>系统解耦</strong>：生产者和消费者不需要直接交互</li><li><strong>异步处理</strong>：提高系统响应速度</li><li><strong>流量削峰</strong>：缓解瞬时高峰流量对系统冲击</li><li><strong>可靠性保证</strong>：确保消息不丢失</li><li><strong>顺序保证</strong>：保证消息按顺序处理</li></ol><h3 id="q2-消息队列的应用场景有哪些" tabindex="-1"><a class="header-anchor" href="#q2-消息队列的应用场景有哪些"><span>Q2: 消息队列的应用场景有哪些？</span></a></h3><p><strong>答：</strong> 消息队列的典型应用场景：</p><ol><li><p><strong>异步处理</strong>：</p><ul><li>用户注册后发送邮件/短信通知</li><li>订单创建后的后续处理</li></ul></li><li><p><strong>应用解耦</strong>：</p><ul><li>电商系统中订单服务与库存服务解耦</li><li>日志收集系统</li></ul></li><li><p><strong>流量削峰</strong>：</p><ul><li>秒杀活动处理</li><li>大促期间订单处理</li></ul></li><li><p><strong>消息通讯</strong>：</p><ul><li>聊天室消息广播</li><li>实时通知推送</li></ul></li></ol><h3 id="q3-常见的消息队列产品有哪些" tabindex="-1"><a class="header-anchor" href="#q3-常见的消息队列产品有哪些"><span>Q3: 常见的消息队列产品有哪些？</span></a></h3><p><strong>答：</strong> 常见的消息队列产品包括：</p><ol><li><strong>ActiveMQ</strong>：老牌消息中间件，功能全面</li><li><strong>RabbitMQ</strong>：基于Erlang开发，可靠性高</li><li><strong>RocketMQ</strong>：阿里巴巴开源，适合大规模分布式系统</li><li><strong>Kafka</strong>：LinkedIn开源，高吞吐量，适合大数据场景</li><li><strong>Redis</strong>：基于内存的NoSQL数据库，也可用作消息队列</li></ol><h2 id="_2-rabbitmq" tabindex="-1"><a class="header-anchor" href="#_2-rabbitmq"><span>2. RabbitMQ</span></a></h2><h3 id="q4-rabbitmq的核心概念有哪些" tabindex="-1"><a class="header-anchor" href="#q4-rabbitmq的核心概念有哪些"><span>Q4: RabbitMQ的核心概念有哪些？</span></a></h3><p><strong>答：</strong> RabbitMQ的核心概念包括：</p><ol><li><strong>Producer（生产者）</strong>：消息的发送方</li><li><strong>Consumer（消费者）</strong>：消息的接收方</li><li><strong>Message（消息）</strong>：传输的数据内容</li><li><strong>Queue（队列）</strong>：存储消息的缓冲区</li><li><strong>Exchange（交换机）</strong>：接收生产者发送的消息并路由到队列</li><li><strong>Binding（绑定）</strong>：交换机和队列之间的关联关系</li><li><strong>Routing Key（路由键）</strong>：用于匹配消息和队列的规则</li><li><strong>Virtual Host（虚拟主机）</strong>：权限隔离的最小单位</li></ol><h3 id="q5-rabbitmq的交换机类型有哪些" tabindex="-1"><a class="header-anchor" href="#q5-rabbitmq的交换机类型有哪些"><span>Q5: RabbitMQ的交换机类型有哪些？</span></a></h3><p><strong>答：</strong> RabbitMQ有四种交换机类型：</p><ol><li><p><strong>Direct Exchange（直连交换机）</strong>：</p><ul><li>完全匹配Routing Key</li><li>消息路由到Binding Key与Routing Key完全匹配的队列</li></ul></li><li><p><strong>Fanout Exchange（扇出交换机）</strong>：</p><ul><li>广播模式</li><li>消息路由到所有绑定的队列，忽略Routing Key</li></ul></li><li><p><strong>Topic Exchange（主题交换机）</strong>：</p><ul><li>模式匹配Routing Key</li><li>支持通配符：*（匹配一个单词）和#（匹配零个或多个单词）</li></ul></li><li><p><strong>Headers Exchange（头交换机）</strong>：</p><ul><li>根据消息头部属性匹配</li><li>忽略Routing Key，使用Headers进行匹配</li></ul></li></ol><h3 id="q6-rabbitmq如何保证消息的可靠性" tabindex="-1"><a class="header-anchor" href="#q6-rabbitmq如何保证消息的可靠性"><span>Q6: RabbitMQ如何保证消息的可靠性？</span></a></h3><p><strong>答：</strong> RabbitMQ保证消息可靠性的机制：</p><ol><li><p><strong>生产者确认机制</strong>：</p><ul><li>事务模式：使用txSelect、txCommit、txRollback</li><li>确认模式：使用confirmSelect、addConfirmListener</li></ul></li><li><p><strong>持久化机制</strong>：</p><ul><li>队列持久化：durable=true</li><li>交换机持久化：durable=true</li><li>消息持久化：deliveryMode=2</li></ul></li><li><p><strong>消费者确认机制</strong>：</p><ul><li>自动确认：autoAck=true</li><li>手动确认：autoAck=false，使用basicAck确认</li></ul></li><li><p><strong>镜像队列</strong>：</p><ul><li>在集群中创建队列的镜像副本</li><li>防止单点故障</li></ul></li></ol><h2 id="_3-rocketmq" tabindex="-1"><a class="header-anchor" href="#_3-rocketmq"><span>3. RocketMQ</span></a></h2><h3 id="q7-rocketmq的架构组成" tabindex="-1"><a class="header-anchor" href="#q7-rocketmq的架构组成"><span>Q7: RocketMQ的架构组成？</span></a></h3><p><strong>答：</strong> RocketMQ的架构组成包括：</p><ol><li><p><strong>NameServer</strong>：</p><ul><li>轻量级服务发现组件</li><li>提供路由管理、服务注册与发现</li></ul></li><li><p><strong>Broker</strong>：</p><ul><li>消息存储和转发服务器</li><li>主从架构，提供高可用性</li></ul></li><li><p><strong>Producer</strong>：</p><ul><li>消息生产者</li><li>与NameServer建立长连接，从NameServer获取Topic路由信息</li></ul></li><li><p><strong>Consumer</strong>：</p><ul><li>消息消费者</li><li>与NameServer建立长连接，从Broker拉取消息</li></ul></li></ol><h3 id="q8-rocketmq的消息类型有哪些" tabindex="-1"><a class="header-anchor" href="#q8-rocketmq的消息类型有哪些"><span>Q8: RocketMQ的消息类型有哪些？</span></a></h3><p><strong>答：</strong> RocketMQ支持的消息类型：</p><ol><li><p><strong>普通消息</strong>：</p><ul><li>最基本的消息类型</li><li>发送即忘模式</li></ul></li><li><p><strong>顺序消息</strong>：</p><ul><li>保证消息按发送顺序消费</li><li>全局顺序消息和分区顺序消息</li></ul></li><li><p><strong>延时消息</strong>：</p><ul><li>消息在指定时间后才能被消费</li><li>支持18个等级的延时时间</li></ul></li><li><p><strong>事务消息</strong>：</p><ul><li>支持分布式事务</li><li>两阶段提交协议</li></ul></li><li><p><strong>批量消息</strong>：</p><ul><li>一次性发送多条消息</li><li>提高发送效率</li></ul></li></ol><h3 id="q9-rocketmq如何保证消息顺序性" tabindex="-1"><a class="header-anchor" href="#q9-rocketmq如何保证消息顺序性"><span>Q9: RocketMQ如何保证消息顺序性？</span></a></h3><p><strong>答：</strong> RocketMQ保证消息顺序性的机制：</p><ol><li><p><strong>分区顺序消息</strong>：</p><ul><li>同一队列中的消息保证有序</li><li>生产者将同一业务标识的消息发送到同一队列</li><li>消费者单线程消费队列消息</li></ul></li><li><p><strong>全局顺序消息</strong>：</p><ul><li>所有消息都发送到同一个队列</li><li>消费者单线程消费</li><li>性能较差，一般不推荐使用</li></ul></li></ol><p>实现要点：</p><ul><li>生产者端：使用MessageQueueSelector选择特定队列</li><li>Broker端：保证同一队列的消息存储顺序</li><li>消费者端：单线程消费或使用顺序消费监听器</li></ul><h2 id="_4-kafka" tabindex="-1"><a class="header-anchor" href="#_4-kafka"><span>4. Kafka</span></a></h2><h3 id="q10-kafka的核心概念有哪些" tabindex="-1"><a class="header-anchor" href="#q10-kafka的核心概念有哪些"><span>Q10: Kafka的核心概念有哪些？</span></a></h3><p><strong>答：</strong> Kafka的核心概念包括：</p><ol><li><strong>Broker</strong>：Kafka集群中的服务器节点</li><li><strong>Topic</strong>：消息的主题分类</li><li><strong>Partition</strong>：主题的分区，提高并发处理能力</li><li><strong>Replica</strong>：分区的副本，保证数据可靠性</li><li><strong>Leader</strong>：主副本，负责读写操作</li><li><strong>Follower</strong>：从副本，同步Leader数据</li><li><strong>Producer</strong>：消息生产者</li><li><strong>Consumer</strong>：消息消费者</li><li><strong>Consumer Group</strong>：消费者组，实现负载均衡</li><li><strong>Offset</strong>：消息在分区中的偏移量</li></ol><h3 id="q11-kafka如何保证高吞吐量" tabindex="-1"><a class="header-anchor" href="#q11-kafka如何保证高吞吐量"><span>Q11: Kafka如何保证高吞吐量？</span></a></h3><p><strong>答：</strong> Kafka保证高吞吐量的机制：</p><ol><li><p><strong>顺序读写磁盘</strong>：</p><ul><li>利用磁盘顺序读写的高性能</li><li>比随机读写快得多</li></ul></li><li><p><strong>零拷贝技术</strong>：</p><ul><li>使用sendfile系统调用</li><li>减少数据在内核态和用户态之间的拷贝</li></ul></li><li><p><strong>批量发送</strong>：</p><ul><li>Producer批量发送消息</li><li>减少网络请求次数</li></ul></li><li><p><strong>数据压缩</strong>：</p><ul><li>支持多种压缩算法（gzip、snappy、lz4）</li><li>减少网络传输和磁盘I/O</li></ul></li><li><p><strong>分区机制</strong>：</p><ul><li>水平扩展，提高并发处理能力</li><li>不同分区可并行处理</li></ul></li></ol><h3 id="q12-kafka如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#q12-kafka如何保证消息不丢失"><span>Q12: Kafka如何保证消息不丢失？</span></a></h3><p><strong>答：</strong> Kafka保证消息不丢失的机制：</p><ol><li><p><strong>生产者端</strong>：</p><ul><li>acks=0：不等待确认（可能丢失）</li><li>acks=1：等待leader确认（leader宕机可能丢失）</li><li>acks=all：等待所有副本确认（不丢失）</li></ul></li><li><p><strong>Broker端</strong>：</p><ul><li>副本机制：每个分区有多个副本</li><li>ISR机制：维护可用副本列表</li><li>HW机制：高水位标记，确保副本间数据一致性</li></ul></li><li><p><strong>消费者端</strong>：</p><ul><li>自动提交offset：可能重复消费</li><li>手动提交offset：确保消费完成后提交</li></ul></li></ol><h2 id="_5-消息队列高级特性" tabindex="-1"><a class="header-anchor" href="#_5-消息队列高级特性"><span>5. 消息队列高级特性</span></a></h2><h3 id="q13-消息队列的两种消费模式" tabindex="-1"><a class="header-anchor" href="#q13-消息队列的两种消费模式"><span>Q13: 消息队列的两种消费模式？</span></a></h3><p><strong>答：</strong> 消息队列的两种消费模式：</p><ol><li><p><strong>点对点模式（Point-to-Point）</strong>：</p><ul><li>一条消息只能被一个消费者消费</li><li>消费者从队列中获取消息</li><li>消息处理完成后从队列中删除</li><li>典型代表：ActiveMQ、RabbitMQ</li></ul></li><li><p><strong>发布订阅模式（Pub/Sub）</strong>：</p><ul><li>一条消息可以被多个消费者消费</li><li>消息发布到主题，订阅者接收消息</li><li>消息不会因为被消费而删除</li><li>典型代表：Kafka、RocketMQ</li></ul></li></ol><h3 id="q14-如何保证消息的幂等性" tabindex="-1"><a class="header-anchor" href="#q14-如何保证消息的幂等性"><span>Q14: 如何保证消息的幂等性？</span></a></h3><p><strong>答：</strong> 保证消息幂等性的方法：</p><ol><li><p><strong>业务层面保证</strong>：</p><ul><li>在数据库中使用唯一约束</li><li>使用业务ID作为主键或唯一索引</li></ul></li><li><p><strong>消息去重</strong>：</p><ul><li>为每条消息生成唯一ID</li><li>在消费端维护已处理消息ID集合</li><li>处理前检查消息是否已处理</li></ul></li><li><p><strong>状态机模式</strong>：</p><ul><li>为业务操作设计状态流转</li><li>只有在特定状态下才执行操作</li></ul></li><li><p><strong>分布式锁</strong>：</p><ul><li>使用Redis等实现分布式锁</li><li>确保同一业务操作不会并发执行</li></ul></li></ol><h3 id="q15-消息积压如何处理" tabindex="-1"><a class="header-anchor" href="#q15-消息积压如何处理"><span>Q15: 消息积压如何处理？</span></a></h3><p><strong>答：</strong> 处理消息积压的方法：</p><ol><li><p><strong>临时扩容</strong>：</p><ul><li>增加消费者实例数量</li><li>提高消费并发度</li></ul></li><li><p><strong>优化消费逻辑</strong>：</p><ul><li>分析消费耗时瓶颈</li><li>优化业务处理逻辑</li><li>批量处理消息</li></ul></li><li><p><strong>降级处理</strong>：</p><ul><li>非核心业务暂时降级</li><li>优先处理重要消息</li></ul></li><li><p><strong>死信队列</strong>：</p><ul><li>将无法处理的消息转移到死信队列</li><li>避免影响正常消息处理</li></ul></li><li><p><strong>监控告警</strong>：</p><ul><li>建立消息积压监控机制</li><li>及时发现并处理积压问题</li></ul></li></ol><h2 id="_6-消息队列选型" tabindex="-1"><a class="header-anchor" href="#_6-消息队列选型"><span>6. 消息队列选型</span></a></h2><h3 id="q16-如何选择合适的消息队列" tabindex="-1"><a class="header-anchor" href="#q16-如何选择合适的消息队列"><span>Q16: 如何选择合适的消息队列？</span></a></h3><p><strong>答：</strong> 选择消息队列的考虑因素：</p><ol><li><p><strong>功能性需求</strong>：</p><ul><li>是否需要严格的消息顺序</li><li>是否需要事务支持</li><li>延时消息需求</li></ul></li><li><p><strong>性能要求</strong>：</p><ul><li>吞吐量要求</li><li>延迟要求</li><li>并发处理能力</li></ul></li><li><p><strong>可靠性要求</strong>：</p><ul><li>消息不丢失要求</li><li>高可用性要求</li></ul></li><li><p><strong>技术栈匹配</strong>：</p><ul><li>团队技术背景</li><li>生态系统集成</li></ul></li><li><p><strong>运维成本</strong>：</p><ul><li>部署复杂度</li><li>监控运维难度</li></ul></li></ol><p>推荐方案：</p><ul><li><strong>高吞吐量场景</strong>：Kafka</li><li><strong>可靠性要求高</strong>：RabbitMQ</li><li><strong>互联网公司</strong>：RocketMQ</li><li><strong>简单场景</strong>：Redis</li></ul><h3 id="q17-消息队列的优缺点" tabindex="-1"><a class="header-anchor" href="#q17-消息队列的优缺点"><span>Q17: 消息队列的优缺点？</span></a></h3><p><strong>答：</strong> 消息队列的优缺点：</p><p><strong>优点：</strong></p><ol><li><strong>解耦</strong>：系统间松耦合</li><li><strong>异步</strong>：提高系统响应速度</li><li><strong>削峰</strong>：应对流量高峰</li><li><strong>可靠性</strong>：确保消息不丢失</li><li><strong>扩展性</strong>：易于水平扩展</li></ol><p><strong>缺点：</strong></p><ol><li><strong>复杂性</strong>：增加系统复杂度</li><li><strong>一致性</strong>：可能出现数据不一致</li><li><strong>可用性</strong>：引入额外故障点</li><li><strong>延迟</strong>：异步处理带来延迟</li><li><strong>运维</strong>：需要专业运维知识</li></ol><h2 id="_7-消息队列实战" tabindex="-1"><a class="header-anchor" href="#_7-消息队列实战"><span>7. 消息队列实战</span></a></h2><h3 id="q18-如何设计一个高可用的消息队列系统" tabindex="-1"><a class="header-anchor" href="#q18-如何设计一个高可用的消息队列系统"><span>Q18: 如何设计一个高可用的消息队列系统？</span></a></h3><p><strong>答：</strong> 设计高可用消息队列系统的要点：</p><ol><li><p><strong>集群部署</strong>：</p><ul><li>多节点集群部署</li><li>避免单点故障</li></ul></li><li><p><strong>数据冗余</strong>：</p><ul><li>多副本机制</li><li>异地多活部署</li></ul></li><li><p><strong>故障转移</strong>：</p><ul><li>自动故障检测</li><li>快速故障切换</li></ul></li><li><p><strong>监控告警</strong>：</p><ul><li>实时监控系统状态</li><li>异常及时告警</li></ul></li><li><p><strong>灾备方案</strong>：</p><ul><li>数据备份策略</li><li>灾难恢复预案</li></ul></li></ol><h3 id="q19-消息队列在微服务中的应用" tabindex="-1"><a class="header-anchor" href="#q19-消息队列在微服务中的应用"><span>Q19: 消息队列在微服务中的应用？</span></a></h3><p><strong>答：</strong> 消息队列在微服务中的应用：</p><ol><li><p><strong>服务解耦</strong>：</p><ul><li>服务间通过消息队列通信</li><li>降低服务间耦合度</li></ul></li><li><p><strong>异步处理</strong>：</p><ul><li>提高系统响应速度</li><li>改善用户体验</li></ul></li><li><p><strong>事件驱动架构</strong>：</p><ul><li>基于事件的业务流程</li><li>实现最终一致性</li></ul></li><li><p><strong>流量控制</strong>：</p><ul><li>削峰填谷</li><li>保护下游服务</li></ul></li><li><p><strong>分布式事务</strong>：</p><ul><li>通过消息队列实现分布式事务</li><li>保证数据一致性</li></ul></li></ol><h2 id="_8-性能优化" tabindex="-1"><a class="header-anchor" href="#_8-性能优化"><span>8. 性能优化</span></a></h2><h3 id="q20-消息队列性能优化策略" tabindex="-1"><a class="header-anchor" href="#q20-消息队列性能优化策略"><span>Q20: 消息队列性能优化策略？</span></a></h3><p><strong>答：</strong> 消息队列性能优化策略：</p><ol><li><p><strong>生产者优化</strong>：</p><ul><li>批量发送消息</li><li>异步发送</li><li>合理设置发送确认机制</li></ul></li><li><p><strong>Broker优化</strong>：</p><ul><li>调整JVM参数</li><li>优化磁盘IO</li><li>合理配置分区和副本</li></ul></li><li><p><strong>消费者优化</strong>：</p><ul><li>批量拉取消息</li><li>多线程消费</li><li>合理设置消费确认机制</li></ul></li><li><p><strong>网络优化</strong>：</p><ul><li>减少网络传输</li><li>使用压缩算法</li><li>优化网络配置</li></ul></li><li><p><strong>监控调优</strong>：</p><ul><li>建立完善的监控体系</li><li>根据监控数据调优</li><li>定期性能测试</li></ul></li></ol>',77)])])}]]),o=JSON.parse('{"path":"/interview/message-queue/","title":"消息队列面试题","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"1. 消息队列基础","slug":"_1-消息队列基础","link":"#_1-消息队列基础","children":[{"level":3,"title":"Q1: 什么是消息队列？它解决了什么问题？","slug":"q1-什么是消息队列-它解决了什么问题","link":"#q1-什么是消息队列-它解决了什么问题","children":[]},{"level":3,"title":"Q2: 消息队列的应用场景有哪些？","slug":"q2-消息队列的应用场景有哪些","link":"#q2-消息队列的应用场景有哪些","children":[]},{"level":3,"title":"Q3: 常见的消息队列产品有哪些？","slug":"q3-常见的消息队列产品有哪些","link":"#q3-常见的消息队列产品有哪些","children":[]}]},{"level":2,"title":"2. RabbitMQ","slug":"_2-rabbitmq","link":"#_2-rabbitmq","children":[{"level":3,"title":"Q4: RabbitMQ的核心概念有哪些？","slug":"q4-rabbitmq的核心概念有哪些","link":"#q4-rabbitmq的核心概念有哪些","children":[]},{"level":3,"title":"Q5: RabbitMQ的交换机类型有哪些？","slug":"q5-rabbitmq的交换机类型有哪些","link":"#q5-rabbitmq的交换机类型有哪些","children":[]},{"level":3,"title":"Q6: RabbitMQ如何保证消息的可靠性？","slug":"q6-rabbitmq如何保证消息的可靠性","link":"#q6-rabbitmq如何保证消息的可靠性","children":[]}]},{"level":2,"title":"3. RocketMQ","slug":"_3-rocketmq","link":"#_3-rocketmq","children":[{"level":3,"title":"Q7: RocketMQ的架构组成？","slug":"q7-rocketmq的架构组成","link":"#q7-rocketmq的架构组成","children":[]},{"level":3,"title":"Q8: RocketMQ的消息类型有哪些？","slug":"q8-rocketmq的消息类型有哪些","link":"#q8-rocketmq的消息类型有哪些","children":[]},{"level":3,"title":"Q9: RocketMQ如何保证消息顺序性？","slug":"q9-rocketmq如何保证消息顺序性","link":"#q9-rocketmq如何保证消息顺序性","children":[]}]},{"level":2,"title":"4. Kafka","slug":"_4-kafka","link":"#_4-kafka","children":[{"level":3,"title":"Q10: Kafka的核心概念有哪些？","slug":"q10-kafka的核心概念有哪些","link":"#q10-kafka的核心概念有哪些","children":[]},{"level":3,"title":"Q11: Kafka如何保证高吞吐量？","slug":"q11-kafka如何保证高吞吐量","link":"#q11-kafka如何保证高吞吐量","children":[]},{"level":3,"title":"Q12: Kafka如何保证消息不丢失？","slug":"q12-kafka如何保证消息不丢失","link":"#q12-kafka如何保证消息不丢失","children":[]}]},{"level":2,"title":"5. 消息队列高级特性","slug":"_5-消息队列高级特性","link":"#_5-消息队列高级特性","children":[{"level":3,"title":"Q13: 消息队列的两种消费模式？","slug":"q13-消息队列的两种消费模式","link":"#q13-消息队列的两种消费模式","children":[]},{"level":3,"title":"Q14: 如何保证消息的幂等性？","slug":"q14-如何保证消息的幂等性","link":"#q14-如何保证消息的幂等性","children":[]},{"level":3,"title":"Q15: 消息积压如何处理？","slug":"q15-消息积压如何处理","link":"#q15-消息积压如何处理","children":[]}]},{"level":2,"title":"6. 消息队列选型","slug":"_6-消息队列选型","link":"#_6-消息队列选型","children":[{"level":3,"title":"Q16: 如何选择合适的消息队列？","slug":"q16-如何选择合适的消息队列","link":"#q16-如何选择合适的消息队列","children":[]},{"level":3,"title":"Q17: 消息队列的优缺点？","slug":"q17-消息队列的优缺点","link":"#q17-消息队列的优缺点","children":[]}]},{"level":2,"title":"7. 消息队列实战","slug":"_7-消息队列实战","link":"#_7-消息队列实战","children":[{"level":3,"title":"Q18: 如何设计一个高可用的消息队列系统？","slug":"q18-如何设计一个高可用的消息队列系统","link":"#q18-如何设计一个高可用的消息队列系统","children":[]},{"level":3,"title":"Q19: 消息队列在微服务中的应用？","slug":"q19-消息队列在微服务中的应用","link":"#q19-消息队列在微服务中的应用","children":[]}]},{"level":2,"title":"8. 性能优化","slug":"_8-性能优化","link":"#_8-性能优化","children":[{"level":3,"title":"Q20: 消息队列性能优化策略？","slug":"q20-消息队列性能优化策略","link":"#q20-消息队列性能优化策略","children":[]}]}],"git":{"contributors":[{"name":"mingwzh","username":"mingwzh","email":"1127699551@qq.com","commits":1,"url":"https://github.com/mingwzh"}],"changelog":[{"hash":"8335c914e5d1588f5f8b9c0590d63a971106f6e5","time":1765444062000,"email":"1127699551@qq.com","author":"mingwzh","message":"feat(docs): 初始化技术面试宝典文档站点"}]},"filePathRelative":"interview/message-queue/README.md"}')}}]);