"use strict";(self.webpackChunkmy_vuepress_site=self.webpackChunkmy_vuepress_site||[]).push([[8090],{4244:(n,l,i)=>{i.r(l),i.d(l,{comp:()=>t,data:()=>e});var s=i(641);const a={},t=(0,i(6262).A)(a,[["render",function(n,l){return(0,s.uX)(),(0,s.CE)("div",null,[...l[0]||(l[0]=[(0,s.Fv)('<h1 id="spring-cloud" tabindex="-1"><a class="header-anchor" href="#spring-cloud"><span>Spring Cloud</span></a></h1><h2 id="_1-spring-cloud基础" tabindex="-1"><a class="header-anchor" href="#_1-spring-cloud基础"><span>1. Spring Cloud基础</span></a></h2><h3 id="q1-什么是spring-cloud-它解决了什么问题" tabindex="-1"><a class="header-anchor" href="#q1-什么是spring-cloud-它解决了什么问题"><span>Q1: 什么是Spring Cloud？它解决了什么问题？</span></a></h3><p><strong>答：</strong> Spring Cloud是一系列框架的有序集合，基于Spring Boot实现，用于快速构建分布式系统的常见模式。</p><p>解决的问题：</p><ul><li><strong>配置管理</strong>：统一管理微服务的配置</li><li><strong>服务发现</strong>：自动发现和注册服务实例</li><li><strong>断路器</strong>：防止服务雪崩</li><li><strong>智能路由</strong>：负载均衡和服务路由</li><li><strong>微代理</strong>：API网关</li><li><strong>控制总线</strong>：分布式系统中的消息传递</li><li><strong>一次性令牌</strong>：安全认证</li><li><strong>全局锁</strong>：分布式锁</li><li><strong>领导选举</strong>：集群中的主节点选举</li><li><strong>分布式会话</strong>：跨服务的会话管理</li><li><strong>集群状态</strong>：监控集群健康状态</li></ul><h3 id="q2-spring-cloud的核心组件有哪些" tabindex="-1"><a class="header-anchor" href="#q2-spring-cloud的核心组件有哪些"><span>Q2: Spring Cloud的核心组件有哪些？</span></a></h3><p><strong>答：</strong> Spring Cloud的核心组件包括：</p><ol><li><p><strong>服务注册与发现</strong>：</p><ul><li>Eureka：Netflix开源的服务发现组件</li><li>Consul：HashiCorp开源的服务发现和配置工具</li><li>Zookeeper：Apache开源的分布式协调服务</li></ul></li><li><p><strong>负载均衡</strong>：</p><ul><li>Ribbon：客户端负载均衡器</li><li>Spring Cloud LoadBalancer：Spring官方的负载均衡器</li></ul></li><li><p><strong>服务调用</strong>：</p><ul><li>Feign：声明式的Web服务客户端</li><li>OpenFeign：Feign的升级版</li></ul></li><li><p><strong>熔断器</strong>：</p><ul><li>Hystrix：断路器模式实现</li><li>Resilience4j：轻量级容错库</li></ul></li><li><p><strong>API网关</strong>：</p><ul><li>Zuul：Netflix开源的API网关</li><li>Spring Cloud Gateway：Spring官方的API网关</li></ul></li><li><p><strong>配置中心</strong>：</p><ul><li>Spring Cloud Config：分布式配置管理</li></ul></li><li><p><strong>消息总线</strong>：</p><ul><li>Spring Cloud Bus：消息总线</li></ul></li><li><p><strong>链路追踪</strong>：</p><ul><li>Sleuth：分布式链路追踪</li><li>Zipkin：分布式追踪系统</li></ul></li></ol><h3 id="q3-微服务架构的优缺点" tabindex="-1"><a class="header-anchor" href="#q3-微服务架构的优缺点"><span>Q3: 微服务架构的优缺点？</span></a></h3><p><strong>答：</strong></p><p><strong>优点：</strong></p><ul><li>技术多样性：不同服务可以使用不同技术栈</li><li>独立部署：每个服务可以独立部署和扩展</li><li>故障隔离：单个服务故障不会影响整个系统</li><li>团队自治：不同团队可以独立开发和维护各自的服务</li><li>可扩展性强：可以根据业务需求独立扩展特定服务</li></ul><p><strong>缺点：</strong></p><ul><li>分布式复杂性：网络延迟、数据一致性等问题</li><li>运维复杂：需要管理多个服务实例</li><li>测试复杂：需要考虑服务间的依赖关系</li><li>网络通信开销：服务间调用增加网络延迟</li><li>数据一致性：分布式事务处理复杂</li></ul><h2 id="_2-服务注册与发现" tabindex="-1"><a class="header-anchor" href="#_2-服务注册与发现"><span>2. 服务注册与发现</span></a></h2><h3 id="q4-eureka的工作原理" tabindex="-1"><a class="header-anchor" href="#q4-eureka的工作原理"><span>Q4: Eureka的工作原理？</span></a></h3><p><strong>答：</strong> Eureka是Netflix开源的服务发现组件，包含两个核心组件：</p><ol><li><p><strong>Eureka Server（服务注册中心）</strong>：</p><ul><li>提供服务注册和发现功能</li><li>维护服务实例的注册信息</li></ul></li><li><p><strong>Eureka Client（服务提供者/消费者）</strong>：</p><ul><li>向Eureka Server注册自身服务</li><li>定期发送心跳维持连接</li><li>获取其他服务的注册信息</li></ul></li></ol><p><strong>工作流程：</strong></p><ol><li>服务启动时向Eureka Server注册服务信息</li><li>Eureka Server保存服务注册信息</li><li>服务消费者定期从Eureka Server获取服务注册信息</li><li>服务提供者定期向Eureka Server发送心跳</li><li>Eureka Server根据心跳检测服务可用性</li><li>服务下线时主动注销或超时后自动剔除</li></ol><h3 id="q5-eureka和consul的区别" tabindex="-1"><a class="header-anchor" href="#q5-eureka和consul的区别"><span>Q5: Eureka和Consul的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>Eureka</th><th>Consul</th></tr></thead><tbody><tr><td>一致性算法</td><td>AP（可用性优先）</td><td>CP（一致性优先）</td></tr><tr><td>服务健康检查</td><td>心跳检测</td><td>多种健康检查方式</td></tr><tr><td>KV存储</td><td>不支持</td><td>支持</td></tr><tr><td>多数据中心</td><td>不支持</td><td>支持</td></tr><tr><td>CAP理论</td><td>AP</td><td>CP</td></tr><tr><td>Web UI</td><td>支持</td><td>支持</td></tr><tr><td>安全性</td><td>相对简单</td><td>ACL和TLS支持</td></tr></tbody></table><h3 id="q6-服务下线的处理机制" tabindex="-1"><a class="header-anchor" href="#q6-服务下线的处理机制"><span>Q6: 服务下线的处理机制？</span></a></h3><p><strong>答：</strong> 服务下线的处理机制包括：</p><ol><li><p><strong>主动下线</strong>：</p><ul><li>服务正常关闭时调用unregister接口</li><li>Eureka Server立即移除服务实例</li></ul></li><li><p><strong>被动下线</strong>：</p><ul><li>服务异常终止，无法发送取消注册请求</li><li>Eureka Server通过心跳检测发现服务不可用</li><li>超过一定时间（默认90秒）未收到心跳则移除实例</li></ul></li><li><p><strong>自我保护机制</strong>：</p><ul><li>当短时间内大量服务实例失去联系时触发</li><li>防止因网络故障误删正常服务实例</li><li>保证注册中心的高可用性</li></ul></li></ol><h2 id="_3-负载均衡" tabindex="-1"><a class="header-anchor" href="#_3-负载均衡"><span>3. 负载均衡</span></a></h2><h3 id="q7-ribbon和spring-cloud-loadbalancer的区别" tabindex="-1"><a class="header-anchor" href="#q7-ribbon和spring-cloud-loadbalancer的区别"><span>Q7: Ribbon和Spring Cloud LoadBalancer的区别？</span></a></h3><p><strong>答：</strong></p><p><strong>Ribbon：</strong></p><ul><li>Netflix开源的客户端负载均衡器</li><li>已进入维护模式，不再积极开发</li><li>基于HTTP和TCP客户端</li><li>集成在Netflix OSS栈中</li></ul><p><strong>Spring Cloud LoadBalancer：</strong></p><ul><li>Spring官方推出的负载均衡器</li><li>用于替代Ribbon</li><li>响应式编程支持</li><li>更好的与Spring生态系统集成</li></ul><h3 id="q8-负载均衡策略有哪些" tabindex="-1"><a class="header-anchor" href="#q8-负载均衡策略有哪些"><span>Q8: 负载均衡策略有哪些？</span></a></h3><p><strong>答：</strong> 常见的负载均衡策略包括：</p><ol><li><strong>轮询（Round Robin）</strong>：按顺序依次分配请求</li><li><strong>随机（Random）</strong>：随机选择服务实例</li><li><strong>权重（Weighted）</strong>：根据权重分配请求</li><li><strong>最少连接（Least Connections）</strong>：选择连接数最少的实例</li><li><strong>响应时间（Response Time）</strong>：选择响应时间最短的实例</li><li><strong>可用性（Availability）</strong>：根据实例的可用性分配请求</li></ol><h2 id="_4-服务调用" tabindex="-1"><a class="header-anchor" href="#_4-服务调用"><span>4. 服务调用</span></a></h2><h3 id="q9-openfeign的工作原理" tabindex="-1"><a class="header-anchor" href="#q9-openfeign的工作原理"><span>Q9: OpenFeign的工作原理？</span></a></h3><p><strong>答：</strong> OpenFeign是声明式的Web服务客户端，使编写Web服务客户端变得更加简单。</p><p><strong>工作原理：</strong></p><ol><li>启动时扫描@FeignClient注解的接口</li><li>为每个接口创建动态代理对象</li><li>解析接口上的注解（@RequestMapping等）</li><li>将方法调用转换为HTTP请求</li><li>通过负载均衡器选择服务实例</li><li>发送HTTP请求并接收响应</li><li>将响应结果反序列化为Java对象</li></ol><p><strong>关键组件：</strong></p><ul><li>Contract：契约，解析注解</li><li>Encoder：编码器，将请求参数编码为HTTP请求体</li><li>Decoder：解码器，将HTTP响应体解码为Java对象</li><li>Client：客户端，发送HTTP请求</li></ul><h3 id="q10-feign如何实现负载均衡" tabindex="-1"><a class="header-anchor" href="#q10-feign如何实现负载均衡"><span>Q10: Feign如何实现负载均衡？</span></a></h3><p><strong>答：</strong> Feign通过集成Ribbon或Spring Cloud LoadBalancer实现负载均衡：</p><ol><li><strong>服务发现</strong>：通过Eureka等服务注册中心获取服务实例列表</li><li><strong>负载均衡算法</strong>：根据配置的负载均衡策略选择服务实例</li><li><strong>请求转发</strong>：将请求发送到选定的服务实例</li></ol><p>配置示例：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code><span class="line"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;user-service&quot;</span><span class="token punctuation">,</span> configuration <span class="token operator">=</span> <span class="token class-name">FeignConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span></span>\n<span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserServiceClient</span> <span class="token punctuation">{</span></span>\n<span class="line">    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/users/{id}&quot;</span><span class="token punctuation">)</span></span>\n<span class="line">    <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-熔断器" tabindex="-1"><a class="header-anchor" href="#_5-熔断器"><span>5. 熔断器</span></a></h2><h3 id="q11-hystrix的熔断机制" tabindex="-1"><a class="header-anchor" href="#q11-hystrix的熔断机制"><span>Q11: Hystrix的熔断机制？</span></a></h3><p><strong>答：</strong> Hystrix的熔断机制包括三个状态：</p><ol><li><p><strong>Closed（关闭状态）</strong>：</p><ul><li>正常状态下，所有请求正常通过</li><li>统计失败率和延迟等指标</li></ul></li><li><p><strong>Open（打开状态）</strong>：</p><ul><li>当失败率达到阈值时触发熔断</li><li>所有请求直接失败，不调用实际服务</li><li>持续一段时间后进入半开状态</li></ul></li><li><p><strong>Half-Open（半开状态）</strong>：</p><ul><li>允许少量请求通过</li><li>如果请求成功则恢复到关闭状态</li><li>如果请求失败则回到打开状态</li></ul></li></ol><h3 id="q12-resilience4j相比hystrix的优势" tabindex="-1"><a class="header-anchor" href="#q12-resilience4j相比hystrix的优势"><span>Q12: Resilience4j相比Hystrix的优势？</span></a></h3><p><strong>答：</strong> Resilience4j相比Hystrix的优势：</p><ol><li><strong>轻量级</strong>：体积小，依赖少</li><li><strong>响应式支持</strong>：天然支持Reactive Streams</li><li><strong>函数式编程</strong>：提供函数式编程接口</li><li><strong>模块化设计</strong>：可以按需引入需要的模块</li><li><strong>更好的性能</strong>：基于Vavr库，性能更好</li><li><strong>活跃的社区</strong>：持续更新和维护</li></ol><h2 id="_6-api网关" tabindex="-1"><a class="header-anchor" href="#_6-api网关"><span>6. API网关</span></a></h2><h3 id="q13-zuul和spring-cloud-gateway的区别" tabindex="-1"><a class="header-anchor" href="#q13-zuul和spring-cloud-gateway的区别"><span>Q13: Zuul和Spring Cloud Gateway的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>Zuul 1.x</th><th>Zuul 2.x</th><th>Spring Cloud Gateway</th></tr></thead><tbody><tr><td>性能</td><td>同步阻塞</td><td>异步非阻塞</td><td>异步非阻塞</td></tr><tr><td>编程模型</td><td>Servlet</td><td>Netty + RxJava</td><td>WebFlux (Reactor)</td></tr><tr><td>过滤器</td><td>请求级别</td><td>请求级别</td><td>交换级别</td></tr><tr><td>路由配置</td><td>properties/yaml</td><td>properties/yaml</td><td>RouteLocator/DSL</td></tr></tbody></table><h3 id="q14-spring-cloud-gateway的核心概念" tabindex="-1"><a class="header-anchor" href="#q14-spring-cloud-gateway的核心概念"><span>Q14: Spring Cloud Gateway的核心概念？</span></a></h3><p><strong>答：</strong> Spring Cloud Gateway的核心概念包括：</p><ol><li><strong>Route（路由）</strong>：路由是构建网关的基本模块，由ID、目标URI、断言集合和过滤器集合组成</li><li><strong>Predicate（断言）</strong>：匹配HTTP请求的条件，如路径、方法、头信息等</li><li><strong>Filter（过滤器）</strong>：对请求和响应进行修改的组件</li></ol><p>配置示例：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml"><pre><code><span class="line"><span class="token key atrule">spring</span><span class="token punctuation">:</span></span>\n<span class="line">  <span class="token key atrule">cloud</span><span class="token punctuation">:</span></span>\n<span class="line">    <span class="token key atrule">gateway</span><span class="token punctuation">:</span></span>\n<span class="line">      <span class="token key atrule">routes</span><span class="token punctuation">:</span></span>\n<span class="line">      <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service</span>\n<span class="line">        <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//user<span class="token punctuation">-</span>service</span>\n<span class="line">        <span class="token key atrule">predicates</span><span class="token punctuation">:</span></span>\n<span class="line">        <span class="token punctuation">-</span> Path=/api/users/<span class="token important">**</span></span>\n<span class="line">        <span class="token key atrule">filters</span><span class="token punctuation">:</span></span>\n<span class="line">        <span class="token punctuation">-</span> StripPrefix=2</span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-配置中心" tabindex="-1"><a class="header-anchor" href="#_7-配置中心"><span>7. 配置中心</span></a></h2><h3 id="q15-spring-cloud-config的工作原理" tabindex="-1"><a class="header-anchor" href="#q15-spring-cloud-config的工作原理"><span>Q15: Spring Cloud Config的工作原理？</span></a></h3><p><strong>答：</strong> Spring Cloud Config为分布式系统提供外部化配置支持。</p><p><strong>架构组成：</strong></p><ol><li><strong>Config Server</strong>：配置服务器，提供配置文件的管理</li><li><strong>Config Client</strong>：配置客户端，从配置服务器获取配置</li></ol><p><strong>工作流程：</strong></p><ol><li>Config Server启动时连接Git仓库或其他存储</li><li>Client启动时向Config Server请求配置</li><li>Config Server从存储中读取配置并返回给Client</li><li>Client将配置加载到应用环境中</li></ol><p><strong>刷新机制：</strong></p><ul><li>通过@RefreshScope注解实现配置刷新</li><li>使用Spring Cloud Bus实现批量刷新</li></ul><h3 id="q16-配置的优先级顺序" tabindex="-1"><a class="header-anchor" href="#q16-配置的优先级顺序"><span>Q16: 配置的优先级顺序？</span></a></h3><p><strong>答：</strong> Spring Cloud Config配置的优先级顺序（从高到低）：</p><ol><li><strong>bootstrap.properties/yml</strong>：引导配置，最先加载</li><li><strong>远程配置中心</strong>：从Config Server获取的配置</li><li><strong>本地配置文件</strong>：application.properties/yml</li><li><strong>环境变量</strong></li><li><strong>命令行参数</strong></li></ol><p>注意事项：</p><ul><li>bootstrap配置优先级最高，不能被覆盖</li><li>远程配置可以覆盖本地配置</li><li>配置刷新时，远程配置会重新加载</li></ul><h2 id="_8-链路追踪" tabindex="-1"><a class="header-anchor" href="#_8-链路追踪"><span>8. 链路追踪</span></a></h2><h3 id="q17-spring-cloud-sleuth的作用" tabindex="-1"><a class="header-anchor" href="#q17-spring-cloud-sleuth的作用"><span>Q17: Spring Cloud Sleuth的作用？</span></a></h3><p><strong>答：</strong> Spring Cloud Sleuth为微服务架构提供分布式链路追踪解决方案。</p><p><strong>主要功能：</strong></p><ol><li><strong>Trace ID和Span ID</strong>：为每个请求分配唯一的Trace ID，为每个操作分配Span ID</li><li><strong>日志关联</strong>：将同一请求的所有日志关联起来</li><li><strong>性能分析</strong>：统计各服务的响应时间和调用次数</li><li><strong>问题定位</strong>：快速定位分布式系统中的性能瓶颈</li></ol><p><strong>集成Zipkin：</strong></p><ul><li>Sleuth负责生成追踪数据</li><li>Zipkin负责收集、存储和展示追踪数据</li></ul><h3 id="q18-分布式事务的解决方案" tabindex="-1"><a class="header-anchor" href="#q18-分布式事务的解决方案"><span>Q18: 分布式事务的解决方案？</span></a></h3><p><strong>答：</strong> 分布式事务的常见解决方案：</p><ol><li><p><strong>两阶段提交（2PC）</strong>：</p><ul><li>准备阶段：协调者询问参与者是否可以提交</li><li>提交阶段：协调者根据参与者响应决定提交或回滚</li></ul></li><li><p><strong>三阶段提交（3PC）</strong>：</p><ul><li>CanCommit阶段</li><li>PreCommit阶段</li><li>DoCommit阶段</li></ul></li><li><p><strong>补偿事务（TCC）</strong>：</p><ul><li>Try：预留资源</li><li>Confirm：确认执行</li><li>Cancel：取消执行</li></ul></li><li><p><strong>消息队列</strong>：</p><ul><li>通过消息队列保证最终一致性</li></ul></li><li><p><strong>Seata</strong>：</p><ul><li>阿里巴巴开源的分布式事务解决方案</li><li>支持AT、TCC、Saga等模式</li></ul></li></ol>',89)])])}]]),e=JSON.parse('{"path":"/interview/spring-cloud/","title":"Spring Cloud","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"1. Spring Cloud基础","slug":"_1-spring-cloud基础","link":"#_1-spring-cloud基础","children":[{"level":3,"title":"Q1: 什么是Spring Cloud？它解决了什么问题？","slug":"q1-什么是spring-cloud-它解决了什么问题","link":"#q1-什么是spring-cloud-它解决了什么问题","children":[]},{"level":3,"title":"Q2: Spring Cloud的核心组件有哪些？","slug":"q2-spring-cloud的核心组件有哪些","link":"#q2-spring-cloud的核心组件有哪些","children":[]},{"level":3,"title":"Q3: 微服务架构的优缺点？","slug":"q3-微服务架构的优缺点","link":"#q3-微服务架构的优缺点","children":[]}]},{"level":2,"title":"2. 服务注册与发现","slug":"_2-服务注册与发现","link":"#_2-服务注册与发现","children":[{"level":3,"title":"Q4: Eureka的工作原理？","slug":"q4-eureka的工作原理","link":"#q4-eureka的工作原理","children":[]},{"level":3,"title":"Q5: Eureka和Consul的区别？","slug":"q5-eureka和consul的区别","link":"#q5-eureka和consul的区别","children":[]},{"level":3,"title":"Q6: 服务下线的处理机制？","slug":"q6-服务下线的处理机制","link":"#q6-服务下线的处理机制","children":[]}]},{"level":2,"title":"3. 负载均衡","slug":"_3-负载均衡","link":"#_3-负载均衡","children":[{"level":3,"title":"Q7: Ribbon和Spring Cloud LoadBalancer的区别？","slug":"q7-ribbon和spring-cloud-loadbalancer的区别","link":"#q7-ribbon和spring-cloud-loadbalancer的区别","children":[]},{"level":3,"title":"Q8: 负载均衡策略有哪些？","slug":"q8-负载均衡策略有哪些","link":"#q8-负载均衡策略有哪些","children":[]}]},{"level":2,"title":"4. 服务调用","slug":"_4-服务调用","link":"#_4-服务调用","children":[{"level":3,"title":"Q9: OpenFeign的工作原理？","slug":"q9-openfeign的工作原理","link":"#q9-openfeign的工作原理","children":[]},{"level":3,"title":"Q10: Feign如何实现负载均衡？","slug":"q10-feign如何实现负载均衡","link":"#q10-feign如何实现负载均衡","children":[]}]},{"level":2,"title":"5. 熔断器","slug":"_5-熔断器","link":"#_5-熔断器","children":[{"level":3,"title":"Q11: Hystrix的熔断机制？","slug":"q11-hystrix的熔断机制","link":"#q11-hystrix的熔断机制","children":[]},{"level":3,"title":"Q12: Resilience4j相比Hystrix的优势？","slug":"q12-resilience4j相比hystrix的优势","link":"#q12-resilience4j相比hystrix的优势","children":[]}]},{"level":2,"title":"6. API网关","slug":"_6-api网关","link":"#_6-api网关","children":[{"level":3,"title":"Q13: Zuul和Spring Cloud Gateway的区别？","slug":"q13-zuul和spring-cloud-gateway的区别","link":"#q13-zuul和spring-cloud-gateway的区别","children":[]},{"level":3,"title":"Q14: Spring Cloud Gateway的核心概念？","slug":"q14-spring-cloud-gateway的核心概念","link":"#q14-spring-cloud-gateway的核心概念","children":[]}]},{"level":2,"title":"7. 配置中心","slug":"_7-配置中心","link":"#_7-配置中心","children":[{"level":3,"title":"Q15: Spring Cloud Config的工作原理？","slug":"q15-spring-cloud-config的工作原理","link":"#q15-spring-cloud-config的工作原理","children":[]},{"level":3,"title":"Q16: 配置的优先级顺序？","slug":"q16-配置的优先级顺序","link":"#q16-配置的优先级顺序","children":[]}]},{"level":2,"title":"8. 链路追踪","slug":"_8-链路追踪","link":"#_8-链路追踪","children":[{"level":3,"title":"Q17: Spring Cloud Sleuth的作用？","slug":"q17-spring-cloud-sleuth的作用","link":"#q17-spring-cloud-sleuth的作用","children":[]},{"level":3,"title":"Q18: 分布式事务的解决方案？","slug":"q18-分布式事务的解决方案","link":"#q18-分布式事务的解决方案","children":[]}]}],"git":{"contributors":[{"name":"mingwzh","username":"mingwzh","email":"1127699551@qq.com","commits":2,"url":"https://github.com/mingwzh"}],"changelog":[{"hash":"198b4c2269cfeabd6c531c0c9d0327c26cc8f513","time":1768282075000,"email":"1127699551@qq.com","author":"mingwzh","message":"docs(docs): 优化文档分类及标题调整"},{"hash":"8335c914e5d1588f5f8b9c0590d63a971106f6e5","time":1765444062000,"email":"1127699551@qq.com","author":"mingwzh","message":"feat(docs): 初始化技术面试宝典文档站点"}]},"filePathRelative":"interview/spring-cloud/README.md"}')}}]);