"use strict";(self.webpackChunkmy_vuepress_site=self.webpackChunkmy_vuepress_site||[]).push([[838],{4982:(a,l,t)=>{t.r(l),t.d(l,{comp:()=>s,data:()=>n});var i=t(641);const e={},s=(0,t(6262).A)(e,[["render",function(a,l){return(0,i.uX)(),(0,i.CE)("div",null,[...l[0]||(l[0]=[(0,i.Fv)('<h1 id="java-基础" tabindex="-1"><a class="header-anchor" href="#java-基础"><span>Java 基础</span></a></h1><h2 id="_1-java基础概念" tabindex="-1"><a class="header-anchor" href="#_1-java基础概念"><span>1. Java基础概念</span></a></h2><h3 id="q1-java语言有哪些特点" tabindex="-1"><a class="header-anchor" href="#q1-java语言有哪些特点"><span>Q1: Java语言有哪些特点？</span></a></h3><p><strong>答：</strong> Java语言具有以下特点：</p><ul><li>面向对象：封装、继承、多态</li><li>平台无关性：一次编写，到处运行（Write Once, Run Anywhere）</li><li>多线程支持</li><li>动态性</li><li>安全性高</li><li>简单易学</li><li>分布式计算支持</li></ul><h3 id="q2-jvm、jre和jdk的区别是什么" tabindex="-1"><a class="header-anchor" href="#q2-jvm、jre和jdk的区别是什么"><span>Q2: JVM、JRE和JDK的区别是什么？</span></a></h3><p><strong>答：</strong></p><ul><li><strong>JVM（Java Virtual Machine）</strong>：Java虚拟机，是Java程序运行的环境，负责执行字节码</li><li><strong>JRE（Java Runtime Environment）</strong>：Java运行时环境，包含JVM和运行Java程序所需的核心类库</li><li><strong>JDK（Java Development Kit）</strong>：Java开发工具包，包含JRE以及编译器、调试器等开发工具</li></ul><h3 id="q3-什么是跨平台特性-java是如何实现跨平台的" tabindex="-1"><a class="header-anchor" href="#q3-什么是跨平台特性-java是如何实现跨平台的"><span>Q3: 什么是跨平台特性？Java是如何实现跨平台的？</span></a></h3><p><strong>答：</strong> 跨平台特性指的是同一份代码可以在不同的操作系统上运行。Java通过JVM实现跨平台特性，Java源代码被编译成与平台无关的字节码（.class文件），然后由不同平台上的JVM将字节码解释成对应平台的机器码执行。</p><h2 id="_2-数据类型和变量" tabindex="-1"><a class="header-anchor" href="#_2-数据类型和变量"><span>2. 数据类型和变量</span></a></h2><h3 id="q4-java中基本数据类型有哪些" tabindex="-1"><a class="header-anchor" href="#q4-java中基本数据类型有哪些"><span>Q4: Java中基本数据类型有哪些？</span></a></h3><p><strong>答：</strong> Java中有8种基本数据类型：</p><ul><li>整型：byte（1字节）、short（2字节）、int（4字节）、long（8字节）</li><li>浮点型：float（4字节）、double（8字节）</li><li>字符型：char（2字节）</li><li>布尔型：boolean（1位）</li></ul><h3 id="q5-和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#q5-和-equals-的区别"><span>Q5: == 和 equals() 的区别？</span></a></h3><p><strong>答：</strong></p><ul><li><strong>==</strong>：比较两个变量本身的值，对于基本类型比较的是值，对于引用类型比较的是内存地址</li><li><strong>equals()</strong>：比较两个对象的内容是否相等，默认情况下在Object类中与==相同，但很多类重写了该方法，如String、Integer等</li></ul><h3 id="q6-string、stringbuilder、stringbuffer的区别" tabindex="-1"><a class="header-anchor" href="#q6-string、stringbuilder、stringbuffer的区别"><span>Q6: String、StringBuilder、StringBuffer的区别？</span></a></h3><p><strong>答：</strong></p><ul><li><strong>String</strong>：不可变字符串，每次修改都会产生新的对象，线程安全</li><li><strong>StringBuilder</strong>：可变字符串，线程不安全，性能较高</li><li><strong>StringBuffer</strong>：可变字符串，线程安全，性能一般</li></ul><h2 id="_3-面向对象编程" tabindex="-1"><a class="header-anchor" href="#_3-面向对象编程"><span>3. 面向对象编程</span></a></h2><h3 id="q7-面向对象的三大特征是什么" tabindex="-1"><a class="header-anchor" href="#q7-面向对象的三大特征是什么"><span>Q7: 面向对象的三大特征是什么？</span></a></h3><p><strong>答：</strong> 面向对象的三大特征是：</p><ol><li><strong>封装（Encapsulation）</strong>：隐藏对象的属性和实现细节，仅对外提供公共访问方式</li><li><strong>继承（Inheritance）</strong>：子类继承父类的属性和方法，提高代码复用性</li><li><strong>多态（Polymorphism）</strong>：同一个接口可以有多个不同的实现，提高程序的扩展性和维护性</li></ol><h3 id="q8-接口和抽象类的区别" tabindex="-1"><a class="header-anchor" href="#q8-接口和抽象类的区别"><span>Q8: 接口和抽象类的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特征</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>关键字</td><td>abstract class</td><td>interface</td></tr><tr><td>实现</td><td>extends</td><td>implements</td></tr><tr><td>构造方法</td><td>可以有</td><td>不能有</td></tr><tr><td>成员变量</td><td>可以有普通成员变量</td><td>只能有常量（public static final）</td></tr><tr><td>方法</td><td>可以有具体方法和抽象方法</td><td>Java 8之前只能有抽象方法，之后可以有默认方法和静态方法</td></tr><tr><td>继承</td><td>单继承</td><td>多实现</td></tr></tbody></table><h3 id="q9-重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#q9-重载和重写的区别"><span>Q9: 重载和重写的区别？</span></a></h3><p><strong>答：</strong></p><ul><li><p><strong>重载（Overload）</strong>：</p><ul><li>在同一个类中</li><li>方法名相同，参数列表不同（个数、类型、顺序）</li><li>返回值类型可以不同</li><li>访问修饰符可以不同</li></ul></li><li><p><strong>重写（Override）</strong>：</p><ul><li>在子类中</li><li>方法名、参数列表、返回值类型都相同</li><li>访问修饰符不能更低（如父类为protected，子类不能为private）</li><li>异常不能比父类更宽泛</li></ul></li></ul><h2 id="_4-集合框架" tabindex="-1"><a class="header-anchor" href="#_4-集合框架"><span>4. 集合框架</span></a></h2><h3 id="q10-java集合框架的基本接口有哪些" tabindex="-1"><a class="header-anchor" href="#q10-java集合框架的基本接口有哪些"><span>Q10: Java集合框架的基本接口有哪些？</span></a></h3><p><strong>答：</strong> Java集合框架的主要接口包括：</p><ul><li><strong>Collection</strong>：集合层次的根接口 <ul><li><strong>List</strong>：有序集合，元素可重复</li><li><strong>Set</strong>：无序集合，元素不可重复</li><li><strong>Queue</strong>：队列接口</li></ul></li><li><strong>Map</strong>：键值对映射接口</li></ul><h3 id="q11-arraylist和linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#q11-arraylist和linkedlist的区别"><span>Q11: ArrayList和LinkedList的区别？</span></a></h3><p><strong>答：</strong></p><ul><li><p><strong>ArrayList</strong>：</p><ul><li>基于动态数组实现</li><li>查询快，增删慢</li><li>线程不安全</li><li>内存占用较少</li></ul></li><li><p><strong>LinkedList</strong>：</p><ul><li>基于双向链表实现</li><li>查询慢，增删快</li><li>线程不安全</li><li>内存占用较多（需要存储前后节点引用）</li></ul></li></ul><h3 id="q12-hashmap的工作原理" tabindex="-1"><a class="header-anchor" href="#q12-hashmap的工作原理"><span>Q12: HashMap的工作原理？</span></a></h3><p><strong>答：</strong> HashMap基于哈希表实现：</p><ol><li>通过key的hashCode()方法计算hash值</li><li>通过hash值和数组长度计算出索引位置</li><li>如果该位置没有元素，则直接插入；如果有元素，则判断key是否相等</li><li>如果key相等则覆盖原值；如果不相等则形成链表（JDK 8以后会转为红黑树）</li></ol><p><strong>关于key相等时的数据可靠性：</strong></p><p>当HashMap中存在相同的key时，Java通过以下机制保证数据的可靠性：</p><ul><li><strong>equals() 和 hashCode() 一致性</strong>：HashMap依赖key对象的hashCode()方法和equals()方法。只有当两个key的hashCode相等且equals()返回true时，才认为是相同的key。</li><li><strong>覆盖策略</strong>：当发现相同的key时，新值会覆盖旧值，这确保了最新的数据总是可用的。</li><li><strong>线程安全性</strong>：在多线程环境下，HashMap本身不是线程安全的，如需保证线程安全应使用ConcurrentHashMap或Collections.synchronizedMap()包装。</li><li><strong>不可变性建议</strong>：推荐使用不可变对象作为key（如String、Integer等），避免因key状态变化导致的数据查找问题。</li></ul><p><strong>关于哈希冲突时的取值准确性：</strong></p><p>当不同的key因hash值相同而存放到同一位置形成链表时，HashMap通过以下机制确保不会取错值：</p><ul><li><strong>逐个比较</strong>：在链表中查找时，HashMap会从头节点开始遍历，对每个节点调用key.equals()方法进行比较。</li><li><strong>精确匹配</strong>：只有当key的hashCode相等且equals()返回true时，才会返回对应的value，确保取到正确的值。</li><li><strong>链表/红黑树遍历</strong>：在JDK 8+中，如果链表长度超过阈值（默认8），会转换为红黑树以提高查找效率，但仍保持基于equals()的精确匹配。</li></ul><p><strong>关于hash和hashCode的区别：</strong></p><p>key的hash和hashCode是两个相关但不同的概念：</p><ul><li><strong>hashCode()</strong>：是Object类中的方法，由key对象自身决定返回值。它是一个整数值，表示对象的原始哈希码。</li><li><strong>hash</strong>：是HashMap内部对key的hashCode进行二次处理后的结果，经过扰动函数进一步打散，以减少哈希冲突的概率。</li><li><strong>关系</strong>：HashMap使用自己的hash()方法对key.hashCode()的结果进行进一步运算，然后再与数组长度进行运算确定最终的存储位置。</li></ul><h3 id="q13-当向list中存放一个数据时-发生了什么" tabindex="-1"><a class="header-anchor" href="#q13-当向list中存放一个数据时-发生了什么"><span>Q13: 当向List中存放一个数据时，发生了什么？</span></a></h3><p><strong>答：</strong> 当向List中添加一个元素时，具体过程取决于List的具体实现：</p><p><strong>对于ArrayList：</strong></p><ol><li>检查数组容量是否足够，如果不够则进行扩容（通常是原容量的1.5倍）</li><li>将新元素放置在数组的末尾位置（size索引处）</li><li>更新size计数器（size++）</li></ol><p><strong>对于LinkedList：</strong></p><ol><li>创建一个新的节点对象，包含要添加的元素</li><li>将新节点链接到链表的末尾</li><li>更新头节点和尾节点的引用</li><li>更新链表大小计数器</li></ol><p><strong>通用步骤：</strong></p><ul><li>对于所有List实现，都会在添加元素后增加列表的大小计数</li><li>如果添加过程中出现异常（如并发修改异常），操作会失败并抛出相应异常</li></ul><h3 id="q14-java异常体系结构" tabindex="-1"><a class="header-anchor" href="#q14-java异常体系结构"><span>Q14: Java异常体系结构？</span></a></h3><p><strong>答：</strong> Java异常体系以Throwable为根类：</p><ul><li><strong>Error</strong>：系统级错误，程序无法处理</li><li><strong>Exception</strong>：程序可以处理的异常 <ul><li><strong>RuntimeException</strong>：运行时异常（非检查异常）</li><li>其他Exception：编译时异常（检查异常）</li></ul></li></ul><h3 id="q15-throw和throws的区别" tabindex="-1"><a class="header-anchor" href="#q15-throw和throws的区别"><span>Q15: throw和throws的区别？</span></a></h3><p><strong>答：</strong></p><ul><li><strong>throw</strong>：用于方法体内，抛出一个具体的异常实例</li><li><strong>throws</strong>：用于方法声明处，声明该方法可能抛出的异常类型</li></ul><h2 id="_6-多线程" tabindex="-1"><a class="header-anchor" href="#_6-多线程"><span>6. 多线程</span></a></h2><h3 id="q16-创建线程的方式有哪些" tabindex="-1"><a class="header-anchor" href="#q16-创建线程的方式有哪些"><span>Q16: 创建线程的方式有哪些？</span></a></h3><p><strong>答：</strong> 创建线程主要有以下几种方式：</p><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口（有返回值）</li><li>使用线程池</li></ol><h3 id="q17-sleep-和wait-的区别" tabindex="-1"><a class="header-anchor" href="#q17-sleep-和wait-的区别"><span>Q17: sleep()和wait()的区别？</span></a></h3><p><strong>答：</strong></p><table><thead><tr><th>特性</th><th>sleep()</th><th>wait()</th></tr></thead><tbody><tr><td>所属类</td><td>Thread</td><td>Object</td></tr><tr><td>是否释放锁</td><td>不释放</td><td>释放</td></tr><tr><td>使用方式</td><td>Thread.sleep()</td><td>object.wait()</td></tr><tr><td>唤醒方式</td><td>时间到自动唤醒</td><td>notify()/notifyAll()唤醒</td></tr><tr><td>作用范围</td><td>当前线程</td><td>当前对象</td></tr></tbody></table><h2 id="_7-io流" tabindex="-1"><a class="header-anchor" href="#_7-io流"><span>7. IO流</span></a></h2><h3 id="q18-java-io流的分类" tabindex="-1"><a class="header-anchor" href="#q18-java-io流的分类"><span>Q18: Java IO流的分类？</span></a></h3><p><strong>答：</strong></p><p>Java IO流按照不同维度可以分为：</p><ol><li>按流向分：输入流、输出流</li><li>按操作单元分：字节流（8位）、字符流（16位）</li><li>按角色分：节点流、处理流</li></ol><h3 id="q19-bio、nio、aio的区别" tabindex="-1"><a class="header-anchor" href="#q19-bio、nio、aio的区别"><span>Q19: BIO、NIO、AIO的区别？</span></a></h3><p><strong>答：</strong></p><ul><li><strong>BIO（Blocking IO）</strong>：同步阻塞IO，一个连接对应一个线程</li><li><strong>NIO（Non-blocking IO）</strong>：同步非阻塞IO，通过Selector实现一个线程管理多个连接</li><li><strong>AIO（Asynchronous IO）</strong>：异步非阻塞IO，读写操作完成后通知应用程序</li></ul>',78)])])}]]),n=JSON.parse('{"path":"/interview/java/basic/","title":"Java 基础","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"1. Java基础概念","slug":"_1-java基础概念","link":"#_1-java基础概念","children":[{"level":3,"title":"Q1: Java语言有哪些特点？","slug":"q1-java语言有哪些特点","link":"#q1-java语言有哪些特点","children":[]},{"level":3,"title":"Q2: JVM、JRE和JDK的区别是什么？","slug":"q2-jvm、jre和jdk的区别是什么","link":"#q2-jvm、jre和jdk的区别是什么","children":[]},{"level":3,"title":"Q3: 什么是跨平台特性？Java是如何实现跨平台的？","slug":"q3-什么是跨平台特性-java是如何实现跨平台的","link":"#q3-什么是跨平台特性-java是如何实现跨平台的","children":[]}]},{"level":2,"title":"2. 数据类型和变量","slug":"_2-数据类型和变量","link":"#_2-数据类型和变量","children":[{"level":3,"title":"Q4: Java中基本数据类型有哪些？","slug":"q4-java中基本数据类型有哪些","link":"#q4-java中基本数据类型有哪些","children":[]},{"level":3,"title":"Q5: == 和 equals() 的区别？","slug":"q5-和-equals-的区别","link":"#q5-和-equals-的区别","children":[]},{"level":3,"title":"Q6: String、StringBuilder、StringBuffer的区别？","slug":"q6-string、stringbuilder、stringbuffer的区别","link":"#q6-string、stringbuilder、stringbuffer的区别","children":[]}]},{"level":2,"title":"3. 面向对象编程","slug":"_3-面向对象编程","link":"#_3-面向对象编程","children":[{"level":3,"title":"Q7: 面向对象的三大特征是什么？","slug":"q7-面向对象的三大特征是什么","link":"#q7-面向对象的三大特征是什么","children":[]},{"level":3,"title":"Q8: 接口和抽象类的区别？","slug":"q8-接口和抽象类的区别","link":"#q8-接口和抽象类的区别","children":[]},{"level":3,"title":"Q9: 重载和重写的区别？","slug":"q9-重载和重写的区别","link":"#q9-重载和重写的区别","children":[]}]},{"level":2,"title":"4. 集合框架","slug":"_4-集合框架","link":"#_4-集合框架","children":[{"level":3,"title":"Q10: Java集合框架的基本接口有哪些？","slug":"q10-java集合框架的基本接口有哪些","link":"#q10-java集合框架的基本接口有哪些","children":[]},{"level":3,"title":"Q11: ArrayList和LinkedList的区别？","slug":"q11-arraylist和linkedlist的区别","link":"#q11-arraylist和linkedlist的区别","children":[]},{"level":3,"title":"Q12: HashMap的工作原理？","slug":"q12-hashmap的工作原理","link":"#q12-hashmap的工作原理","children":[]},{"level":3,"title":"Q13: 当向List中存放一个数据时，发生了什么？","slug":"q13-当向list中存放一个数据时-发生了什么","link":"#q13-当向list中存放一个数据时-发生了什么","children":[]},{"level":3,"title":"Q14: Java异常体系结构？","slug":"q14-java异常体系结构","link":"#q14-java异常体系结构","children":[]},{"level":3,"title":"Q15: throw和throws的区别？","slug":"q15-throw和throws的区别","link":"#q15-throw和throws的区别","children":[]}]},{"level":2,"title":"6. 多线程","slug":"_6-多线程","link":"#_6-多线程","children":[{"level":3,"title":"Q16: 创建线程的方式有哪些？","slug":"q16-创建线程的方式有哪些","link":"#q16-创建线程的方式有哪些","children":[]},{"level":3,"title":"Q17: sleep()和wait()的区别？","slug":"q17-sleep-和wait-的区别","link":"#q17-sleep-和wait-的区别","children":[]}]},{"level":2,"title":"7. IO流","slug":"_7-io流","link":"#_7-io流","children":[{"level":3,"title":"Q18: Java IO流的分类？","slug":"q18-java-io流的分类","link":"#q18-java-io流的分类","children":[]},{"level":3,"title":"Q19: BIO、NIO、AIO的区别？","slug":"q19-bio、nio、aio的区别","link":"#q19-bio、nio、aio的区别","children":[]}]}],"git":{"contributors":[{"name":"mingwzh","username":"mingwzh","email":"1127699551@qq.com","commits":6,"url":"https://github.com/mingwzh"}],"changelog":[{"hash":"198b4c2269cfeabd6c531c0c9d0327c26cc8f513","time":1768282075000,"email":"1127699551@qq.com","author":"mingwzh","message":"docs(docs): 优化文档分类及标题调整"},{"hash":"a33d71798f8bac0c69c422714bf833e2555d22c1","time":1768016916000,"email":"1127699551@qq.com","author":"mingwzh","message":"docs(java): 补充HashMap中key相等和哈希冲突的详细说明"},{"hash":"debb8fb8ab4e227db3f4fd78a71c81d7338580c8","time":1766386826000,"email":"1127699551@qq.com","author":"mingwzh","message":"docs(java): expand and update basic interview Q&amp;A content"},{"hash":"61c75eab2ed8438af571b58656e55f63e1f9ec78","time":1765958565000,"email":"1127699551@qq.com","author":"mingwzh","message":"docs(interview): 完善Java面试基础文档中的格式和内容"},{"hash":"cdfa5fc4c5e1dc8e134e5f320c14b3d4ad48de63","time":1765957424000,"email":"1127699551@qq.com","author":"mingwzh","message":"docs(java): 优化接口和抽象类区别部分格式"},{"hash":"8335c914e5d1588f5f8b9c0590d63a971106f6e5","time":1765444062000,"email":"1127699551@qq.com","author":"mingwzh","message":"feat(docs): 初始化技术面试宝典文档站点"}]},"filePathRelative":"interview/java/basic/README.md"}')}}]);